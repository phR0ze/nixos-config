{ config, lib, pkgs, f, cfg, ... }: with lib.types;
let
  machine = config.machine;
in
{
  config = lib.mkIf cfg.enable {

    # Common assertions among services
    assertions = [
      # Debug assertion
      #{ assertion = (cfg ? "debug");
      #  message = "echo '${builtins.toJSON cfg}' | jq"; }

      { assertion = (cfg ? "name" && cfg.name != "");
        message = "Requires 'service.cont.${cfg.name}.name' => '${builtins.toJSON cfg.name}' be set to the service name"; }
      { assertion = (machine.net.nic0.name != "");
        message = "Requires 'machine.net.nic0.name' => '${builtins.toJSON machine.net.nic0.name}' be set to a NIC name"; }
      { assertion = (machine.net.nic0.ip != "");
        message = "Requires 'machine.net.nic0.ip' => '${builtins.toJSON machine.net.nic0.ip}' be set to a static IP address"; }
      { assertion = (cfg ? "port" && cfg.port > 0);
        message = "Requires 'service.cont.${cfg.name}.port' => '${builtins.toJSON cfg.port}' be set"; }
      { assertion = (cfg ? "user" && cfg.user ? "name" && cfg.user.name != null && cfg.user.name != "");
        message = "Requires 'service.cont.${cfg.name}.user.name' => '${builtins.toJSON cfg.user.name}' be set"; }
      { assertion = (cfg ? "user" && cfg.user ? "group" && cfg.user.group != null && cfg.user.group != "");
        message = "Requires 'service.cont.${cfg.name}.user.group' => '${builtins.toJSON cfg.user.group}' be set"; }
      { assertion = (cfg ? "user" && cfg.user ? "uid" && cfg.user.uid != null && cfg.user.uid > 0);
        message = "Requires 'service.cont.${cfg.name}.user.uid' => '${builtins.toJSON cfg.user.uid}' be set"; }
      { assertion = (cfg ? "user" && cfg.user ? "gid" && cfg.user.gid != null && cfg.user.gid > 0);
        message = "Requires 'service.cont.${cfg.name}.user.gid' => '${builtins.toJSON cfg.user.gid}' be set"; }
    ];

    # Requires podman virtualization to be configured
    virtualisation.podman.enable = true;

    # Create app user to run the container as for extra security
    users.users.${cfg.user.name} = {
      isNormalUser = true;
      uid = cfg.user.uid;
      group = cfg.user.group;

      # Assign the app user space to use, defaults to 0700 permission
      home = "/var/lib/${cfg.user.name}";
      createHome = true;
    };
    users.groups.${cfg.user.group} = {
      gid = cfg.user.gid;
    };

    # Setup firewall exceptions
    networking.firewall.interfaces.${machine.net.bridge.name}.allowedTCPPorts = [ cfg.port ];

    # Create a dedicated container network to keep the app isolated from other services
    systemd.services."podman-network-${cfg.name}" = {
      serviceConfig = {
        Type = "oneshot";
        RemainAfterExit = true;
        ExecStop = [
          "${pkgs.podman}/bin/podman network rm -f ${cfg.name}"
        ];
      };
      script = ''
        if ! ${pkgs.podman}/bin/podman network exists ${cfg.name}; then
          ${pkgs.podman}/bin/podman network create ${cfg.name}
        fi
      '';
    };

    # Add additional configuration to the above generated app service unit i.e. acts as an overlay.
    # We simply match the name here that is autogenerated from the oci-container directive.
    systemd.services."podman-${cfg.name}" = {
      wantedBy = [ "multi-user.target" ];

      wants = [
        "network-online.target"
        "podman-network-${cfg.name}.service"
      ];
      after = [
        "network-online.target"
        "podman-network-${cfg.name}.service"
      ];

      serviceConfig = {
        Restart = "always";
        WorkingDirectory = "/var/lib/${cfg.name}";
      };
    };
  };
}
