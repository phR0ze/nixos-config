#!/usr/bin/env bash
set -euo pipefail           # configure an immediate fail if something goes badly
shopt -s extglob            # enable extended globbing

# --------------------------------------------------------------------------------------------------
# Install the indicated files to the system
#
# Usage:
#   ./options/files/install STORE_PATH NIX_PATH
# Example:
#   ./options/files/install /nix/store/apzmd7w7kl9nhx66sxiagn9dv09v01m8-files /nix
#
# ### Backlog
#
# ### Testing
# - run tests with the following where temp is a directory full of files representing the store path
#   ./options/files/install temp .
#
# - you can quickly delete all installed files by just pointing at an empty directory as your source
#   mkdir test; ./options/files/install test .
# --------------------------------------------------------------------------------------------------
pkg="$(realpath "$1")"    # the /nix/store path with all the files that need installed
dst="$(realpath "$2")"    # destination directory for tracking e.g. /nix
files="$dst/files"        # link to current files store path
log="$dst/files.log"      # file tracking all files copied or linked
tmplog="$dst/files.tmp"   # old file tracking all files copied or linked

# Read the metadata for the file and/or directories
# Sets global variables:
# - dirmode
# - filemode
# - user
# - group
metadata() {
  local _metafile="${1}" # name of the metadata file to read

  # Read the copy metadata into an array
  # - t trims the newline off the string
  readarray -t meta < "$_metafile"
  kind="${meta[0]}"      # kind of object: file, link, dir
  src="${meta[1]}"       # nix store path of the object
  dirmode="${meta[2]}"   # get trimmed dirmode
  filemode="${meta[3]}"  # get trimmed filemode
  user="${meta[4]}"      # get trimmed user
  group="${meta[5]}"     # get trimmed group
  own="${meta[6]}"       # get trimmed group
}

# Create missing directories with the given metadata in dirmode, user, group
mkdir_p() {
  local _dir="$(dirname "$1")"            # directory of the file we are working with

  # Recurse until we get to an existing directory
  if [[ -d "$_dir" ]]; then
    return
  else
    mkdir_p "$_dir"
  fi

  # Create the missing directory component
  echo "    mkdir: $_dir"
  echo "        >> kind=$kind, own=$own, dirmode=$dirmode, filemode=$filemode, user=$user, group=$group"
  mkdir -m $dirmode "$_dir"
  chown $user:$group "$_dir"
}

# Copy the given source store path to the implicated destination using the metadata file for mode, 
# user and group properties
copy() {
  local _src="${1}"                         # intermediate source path e.g. /nix/files/etc/foo
  local _target="${1#"$files"}"             # trim off the nix pkg prefix e.g. /etc/foo

  # Create any needed directories
  mkdir_p "$_target"

  echo "  copying: $_src -> $_target"
  echo "        >> kind=$kind, own=$own, dirmode=$dirmode, filemode=$filemode, user=$user, group=$group"

  # install
  # - is more performant as it does this operation in one go
  # - overwrites the existing target if it exists
  # - resolves link indirection recursively to find original source
  install -C -m $filemode -o $user -g $group "$_src" "$_target"

  # Only track the file if we own it
  if [[ "$own" == "true" ]]; then
    echo "$_target" >> "$log"
  fi
}

# Link the given source store path to the implicated destination
link() {
  local _src="${1}"                         # intermediate source path e.g. /nix/files/etc/foo
  local _target="${1#"$files"}"             # trim off the nix pkg prefix e.g. /etc/foo

  # Create any needed directories
  mkdir_p "$_target"

  # Update link if it doesn't exist or is incorrect
  if [[ ! -e "$_target" ]]; then
    echo "  linking: $_src -> $_target"
    echo "        >> kind=$kind, own=$own, dirmode=$dirmode, filemode=$filemode, user=$user, group=$group"
    ln -sf "$_src" "$_target"
  elif [[ "$(realpath "$_target")" != "$src" ]]; then
    echo " updating: $_src -> $_target"
    echo "        >> kind=$kind, own=$own, dirmode=$dirmode, filemode=$filemode, user=$user, group=$group"
    rm -f "$_target"                       # cleaner to just ensure it doesn't exist
    ln -sf "$_src" "$_target"
  else
    echo "  leaving: $_src -> $_target"
    echo "        >> kind=$kind, own=$own, dirmode=$dirmode, filemode=$filemode, user=$user, group=$group"
  fi

  # Only track the link if we own it
  if [[ "$own" == "true" ]]; then
    echo "$_target" >> "$log"
  fi
}

# Clean up any files left over from the previous install
clean() {
  readarray -t oldfiles < "$tmplog"       # read in all the old files
  readarray -t newfiles < "$log"          # read in all the new files

  # Nested loop to check if any oldfiles no longer exist
  for x in "${oldfiles[@]}"; do

    # Search the new files
    local _exists=false
    for y in "${newfiles[@]}"; do
      if [[ "$x" == "$y" ]]; then
        _exists=true
        break
      fi
    done

    # Remove the file if it no longer exists
    if [[ "$_exists" != true ]]; then
      echo " removing: $x"
      if [[ -d "$x" ]]; then
        rm -rf "$x"
      else
        rm -f "$x"
      fi
    fi
  done
}

# Loop through directories
# - handles spaces in directory names
mkdirs() {
  local _target
  find "$pkg" -name ".meta.dir" | while read x; do
    metadata "$x"                             # load the metadata
    _target="${x#"$pkg"}"                     # trim off the store path prefix
    mkdir_p "$_target"                        # create all directories

    # Only track the link if we own it
    if [[ "$own" == "true" ]]; then
      echo "$(dirname "$_target")" >> "$log"
    fi
  done
}

# Loop through files
# - handles spaces in file names
mkfiles() {
  local _src
  find "$pkg" -name "*.meta.file" | while read x; do
    metadata "$x"                             # load the metadata
    _src="${x#"$pkg"}"                        # trim off the nix pkg prefix e.g. /etc/foo
    _src="${_src%".meta.file"}"               # trim off the .meta.file suffix

    # Use the saved pkg link /nix/files as an intermediate to store path.
    # In this way we can switch all links at once when we update the 'files' link.
    _src="${files}${_src}"                    # add on new path prefix e.g. /nix/files/etc/foo

    # copy nix store path item to system
    if [[ "$kind" == "file" ]]; then
      copy "$_src"
    fi

    # link nix store path item to system
    if [[ "$kind" == "link" ]]; then
      link "$_src"
    fi
  done
}

# Install files
# --------------------------------------------------------------------------------------------------
echo "installing files from ${pkg}"

# Save off the existing tracking files
[[ ! -e "$log" ]] && touch "$log"
mv "$log" "$tmplog" && touch "$log"

# Update the source store path first to avoid creating this as a directory during the file directory 
# creation process. This will switch all linked files over to our new source store path.
if [[ ! -e "$files" ]]; then
  ln -sf "$pkg" "$files"
elif [[ "$(realpath "$files")" != "$pkg" ]]; then
  rm -f "$files"
  ln -sf "$pkg" "$files"
fi

mkdirs      # make dirs first
mkfiles     # make files second
clean       # clean up last
