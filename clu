#! /usr/bin/env bash

# MIT License
# Copyright (c) 2024 phR0ze
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# --------------------------------------------------------------------------------------------------
# Simple NixOS install automation
# 
# ## Features
# - Handles partitioning the disk in preparation for installation
# - Allows for customizing some common install settings
#   - hostname
# --------------------------------------------------------------------------------------------------
none="\e[m"
red="\e[1;31m"
cyan="\e[1;36m"
green="\e[1;32m"
yellow="\e[1;33m"

DEBUG=0

# Determine the script name and absolute root path of the project
SCRIPT=$(basename $0)
PROJECT_DIR=$(readlink -f $(dirname $BASH_SOURCE[0]))

# Print out a header
# --------------------------------------------------------------------------------------------------
# ### Params
# - $1 char to use for the separation line
# - $2 color to use
# - $3 header message
# - $4 double header or not 1/0
header()
{
    local char=$1
    local color=$2
    local msg=$3
    local double=$4

    # If the message has no color then colorize it
    [[ "${msg}" != *"\e[1"* ]] && msg="${color}${msg}${none}"

    echo
    [ "x$double" == "x1" ] && echo -e ${color}$_{1..80}'\b'"${char}"${none}
    echo -e ":: ${msg}"
    echo -e ${color}$_{1..80}'\b'"${char}"${none}
}

# Dump out debug variables
debug_vars()
{
    log_d ">> Debug variables"
    #log_d "   READ_MNT:  $READ_MNT"
}

# Common exit code for debug logging
exit_to_shell()
{
    debug_vars
    exit
}

check_status()
{
    if [ $? -ne 0 ]; then
        echo -e "${red}failed!${none}"
        exit_to_shell
    else
        [ "$1" != "nomsg" ] && echo -e "${green}success!${none}"
    fi
}

# Takes the value in $1 and prints it out if in debug mode
log_d()
{
    local msg=$1

    if [ "x${DEBUG}" == "x1" ]; then
        echo -e "${yellow}$msg${none}"
    fi
}

# Retrieve input from user
# --------------------------------------------------------------------------------------------------
# ### Params
# - $1 return variable name to be set
# - $2 message to display to the user to prompt for input
# - $3 default value to use if no value was input
# - $4 if 's' don't echo result, if 'f' ignore automation and require user input
#
# Special commands:
# Instead of answering the input query the user can use these special commands to invoke debugging
# - "debug" will switch to debug mode
# - "exit" will exit to shell
getinput()
{
    local _result=$1
    local msg=$2
    local result=$3
    local multi=$4

    # Notify user as directed
    echo -en "   ${msg} (default=${cyan}${result}${none}): "

    # Defaulting settings is true then add a newline to format nicely
    [ "x$multi" != "xf" ] && [ "x$DEFAULT" == "xy" ] && echo ''

    # Handle non default options 
    if [ "x$multi" == "xf" ] || [ "x$DEFAULT" == "xn" ]; then
        if [ "x$multi" == "xs" ]; then
            read -s value
            echo ''
        else
            read value
        fi

        # Handle debug user input
        [[ "$value" == *"debug"* ]] && DEBUG=1 && value=""
        [[ "$value" == *"exit"* ]] && exit_to_shell

        # Handle normal user input
        [ "x$value" != "x" ] && local result="$value"
    fi

    eval "$_result"="$result"
}

# Get the user's selection from an array of options
# --------------------------------------------------------------------------------------------------
# ### Params
# - $1 return variable name to be set
# - $2 array of options to select from
getsel()
{
    local _result=$1
    local options=$2
    local result=''

    # Array length + 1 since we are starting with 1 rather than 0
    local out_of_bounds=$((${#a[@]}+1))

    # Present options and retry if an invalid selection is given
    while true; do
        echo -en "   Enter your numbered selection (default=${cyan}1${none}): "
        [ "x$DEFAULT" == "xy" ] && echo '' || read choice
        [ "$choice" == "exit" ] && exit_to_shell
        [ "x$choice" == "x" ] && choice=1
        if [ $choice -gt 0 ] && [ $choice -le $out_of_bounds ]; then
            choice=$((choice-1))
            local result=${options[$choice]}
            break
        else
            echo -e "   ${red}Invalid selection, please try again${none}"
       fi
    done

    eval $_result=$result
}

# Replace the given value in the given file
# --------------------------------------------------------------------------------------------------
# ### Params
# - $1 type of replacement [str | bool]
# - $2 value to search for
# - $3 value to replace with
# - $4 file to target
replace()
{
    kind=$1
    target=$2
    value=$3
    file=$4

    if [ "x$kind" == "xbool" ]; then
        sed -i -e "s|\(^.*${target} = \).*\(;.*$\)|\1${value}\2|" "${file}"
    elif [ "x$kind" == "xstr" ]; then
        sed -i -e "s|\(^.*${target} = \"\).*\(\";.*$\)|\1${value}\2|" "${file}"
    fi
}

# Partition disk and mount for install at ${ROOT_MOUNT}
partition_and_mount_disk()
{
    header '-' "${cyan}" "Partitioning and mounting destination disk ${cyan}${DESTDEV}${none}..."

    # Wipe, partition and format disk
    # --------------------------------------------------------------------------
    echo -e ":: ${red}WARNING this will DESTROY all data on disk:${none} ${cyan}${DESTDEV}${none}"
    getinput DESTROY 'Do you wish to continue?' 'n' 'f'
    [ "x${DESTROY}" != "xy" ] && [ "x${DESTROY}" != "xskip" ] && exit
    [ "x${DESTROY}" == "xskip" ] && return

    echo -en "\n:: Destroying any magic strings and/or signatures on ${cyan}${DESTDEV}${none}..."
    wipefs --all --force ${DESTDEV} &>/dev/null
    check_status

    echo -en ":: Wiping partition table on ${cyan}${DESTDEV}${none}..."
    sgdisk --zap ${DESTDEV} &>/dev/null
    check_status

    # Set partition identifiers
    if [ "x${SCSI}" == "x1" ]; then
        PART_BOOT="${DESTDEV}1"
        PART_SWAP="${DESTDEV}2"
        PART_ROOT="${DESTDEV}3"
    else
        PART_BOOT="${DESTDEV}p1"
        PART_SWAP="${DESTDEV}p2"
        PART_ROOT="${DESTDEV}p3"
    fi

    # EFI: Create an ESP (EFI system partition) using linux code EF00
    # to act as a storage place for the EFI bootloaders to be launched by the UEFI firmware.
    # https://wiki.archlinux.org/index.php/EFI_System_Partition#Create_the_partition
    if [ "x${EFI}" == "x1" ]; then
        echo -en ":: Creating ${cyan}${PART_BOOT}${none} as ${cyan}ESP boot partition${none}..."
        sgdisk -n 0:0:+512M -t 0:EF00 -c 0:"EFI system" ${DESTDEV} &>/dev/null
        check_status

        echo -en ":: Formatting ${cyan}${PART_BOOT}${none} (ESP) as ${cyan}FAT32${none}..."
        mkfs.vfat -n "BOOT" ${PART_BOOT} &>/dev/null
        check_status

    # BIOS: Create a BIOS boot partition EF02
    else
        echo -en ":: Creating ${cyan}${PART_BOOT}${none} as ${cyan}BIOS boot partition${none}..."
        sgdisk -n 0:0:+2M -t 0:EF02 -c 0:"BIOS system" ${DESTDEV} &>/dev/null
        check_status
    fi

    # Create SWAP partition 8200
    echo -en ":: Creating ${cyan}${PART_SWAP}${none} as ${cyan}Linux swap partition${none}..."
    sgdisk -n 0:0:+4G -t 0:8200 -c 0:"Linux swap" ${DESTDEV} &>/dev/null
    check_status

    # Create root partition 8300
    echo -en ":: Creating ${cyan}${PART_ROOT}${none} as ${cyan}Linux filesystem partition${none}..."
    sgdisk -n 0:0:0 -t 0:8300 -c 0:"Linux filesystem" ${DESTDEV} &>/dev/null
    check_status

    # Set boot flag for device
    echo -en ":: Setting boot flag on ${cyan}${DESTDEV}${none}..."
    sgdisk ${DESTDEV} --attributes=3:set:2 &>/dev/null
    check_status

    # Configure swap partition
    echo -en ":: Formatting ${cyan}${PART_SWAP}${none} as ${cyan}swap${none}..."
    mkswap -L SWAP ${PART_SWAP} &>/dev/null
    check_status
    echo -en ":: Starting swap on ${cyan}${PART_SWAP}${none}..."
    swapon ${PART_SWAP} &>/dev/null
    check_status

    # mkfs.ext4 option descriptions
    # -F            force creation even if some params don't make sense
    # -L            set volume name to well known label used by bootloaders
    # -m 0          don't reserve blocks for super user daemons
    # -q            run in quiet mode for scripts
    echo -en ":: Formatting ${cyan}${PART_ROOT}${none} as ${cyan}ext4${none}..."
    mkfs.ext4 -F -m 0 -q -L ROOT ${PART_ROOT} &>/dev/null
    check_status

    # Mount root as ROOT_MOUNT and disable access time writes (speeds things up)
    echo -en ":: Mounting ${cyan}${PART_ROOT}${none} as ${cyan}${ROOT_MOUNT}${none}..."
    mount -o noatime ${PART_ROOT} ${ROOT_MOUNT} &>/dev/null
    check_status

    # UEFI: boot partition needs to be mounted over the root at /boot to capture the Linux
    # standard boot file install e.g. kernel and initramfs. We keep them on the same partition
    # as the EFI/BOOT/BOOTX64.efi as EFI can't mount a ext4 filesystem.
    if [ "x${EFI}" == "x1" ]; then
        echo -en ":: Mounting ${cyan}${PART_BOOT}${none} (ESP) as ${cyan}${ROOT_MOUNT}/boot${none}..."
        mkdir -p ${ROOT_MOUNT}/boot
        mount ${PART_BOOT} ${ROOT_MOUNT}/boot &>/dev/null
        check_status
    fi
    # BIOS: boot partition shouldn't be formatted or mounted in this case as its just for the MBR
}

config_system()
{
    # Setup the NixOS configuration files
    # This must be done after the disk partioning so that the system picks up the new partitions
    # ----------------------------------------------------------------------------------------------
    header '-' "${cyan}" "Setup NixOS configurations files at ${cyan}${NIXOS_CONFIG}${none}"

    # Copy the cloned configuration to the newly partitioned drive
    cp -r $SCRIPT_DIR/. ${NIXOS_CONFIG}

    # Generate the hardware-configuration.nix and configuration.nix
    nixos-generate-config --root ${ROOT_MOUNT}
    check_status

    # Modules must be at least staged for the flake to recognize them
    pushd ${NIXOS_CONFIG}
    git add hardware-configuration.nix
    popd

    # Extract the current NIXOS version from teh generated configuration.nix file
    NIXOS_VER=$(sed -n 's|^\s*system.stateVersion\s*=\s*"\(.*\)";.*|\1|p' "${NIXOS_CONFIG}/configuration.nix")
    echo -en ":: NIXOS target version: ${cyan}${NIXOS_VER}${none}..."
    check_status
    rm -f "${NIXOS_CONFIG}/configuration.nix" # clean up

    # Configuring user set values
    # ----------------------------------------------------------------------------------------------
    replace str "stateVersion" "${NIXOS_VER}" "${NIXOS_CONFIG}/flake.nix"

    # Configure new user and root user
    local pass=""
    [ "x$DEFAULT" == "xy" ] && pass=" (default: ${cyan}${DEFAULT_PASS}${none})"
    echo -en ":: Setting new user ${cyan}${USER_NAME}${none} and ${cyan}root${none} user passwords${pass}..."
    replace str "username" "${USER_NAME}" "${NIXOS_CONFIG}/flake.nix"
    replace str "userpass" "${USER_PASS}" "${NIXOS_CONFIG}/flake.nix"
    replace str "name" "${USER_NAME}" "${NIXOS_CONFIG}/flake.nix"
    replace str "email" "${USER_EMAIL}" "${NIXOS_CONFIG}/flake.nix"
    [ "x${AUTO_LOGIN}" == "x1" ] && autologin="true" || autologin="false"
    replace bool "autologin" "${autologin}" "${NIXOS_CONFIG}/flake.nix"
    check_status

    # Configure boot device target
    echo -en ":: Configure boot device type..."
    [ "x${EFI}" == "x1" ] && efi_str="true" || efi_str="false"
    replace bool "efi" "${efi_str}" "${NIXOS_CONFIG}/flake.nix"

    [ "x${EFI}" == "x1" ] && mbr_str="nodev" || mbr_str="${DESTDEV}"
    replace str "mbr" "${mbr_str}" "${NIXOS_CONFIG}/flake.nix"
    check_status

    # Configure system settings
    replace str "timezone" "${TIMEZONE}" "${NIXOS_CONFIG}/flake.nix"
    replace str "hostname" "${HOSTNAME}" "${NIXOS_CONFIG}/flake.nix"
    replace str "profile" "${PROFILE}" "${NIXOS_CONFIG}/flake.nix"

    # Execute the NixOS install
    # ----------------------------------------------------------------------------------------------
    header '-' "${cyan}" "Installing NixOS configuration" 1
    nixos-install --no-root-passwd --no-channel-copy --flake "${NIXOS_CONFIG}#install"

#    # Configure time and date
#    # --------------------------------------------------------------------------
#    if [ "x$TIMEDATE_SET" == "xy" ]; then
#        local now=$(date --iso-8601=seconds)
#        echo -en ":: Set time and date to ${cyan}${now}${none}..."
#        chroot ${ROOT_MOUNT} date -s ${now} &>/dev/null
#        check_status
#    fi
#
#    echo -en ":: Set hwclock to system clock ${cyan}${TIMEDATE}${none}..."
#    chroot ${ROOT_MOUNT} hwclock --systohc &>/dev/null
#    check_status
}

# Start the install wizard
# --------------------------------------------------------------------------------------------------
installer()
{
    # Default installer values
    # ----------------------------------------------------------------------------------------------
    SCSI=0
    DEFAULT='n'
    TIMEZONE='America/Boise'
    NETIP='DHCP'
    HOSTNAME='nixos'
    USER_NAME='admin'
    USER_PASS='admin'
    USER_EMAIL='nixos@nixos.org'
    DEFAULT_PASS='admin'
    ROOT_MOUNT='/mnt'
    PROFILE='base/bootable'
    NIXOS_CONFIG="${ROOT_MOUNT}/etc/nixos"

    # Detect EFI supported system
    [ -d /sys/firmware/efi ] && EFI=1 || EFI=0

    # Determine if this is a default deployment
    # ----------------------------------------------------------------------------------------------
    echo -e "${cyan}:: Automatically deploy with defaults?${none}"
    getinput DEFAULT 'Use automatic mode with defaults' 'n'
    if [ "x$DEFAULT" == "xy" ]; then
        AUTO_LOGIN=1
    fi

    # Drop out debug variables if in debug mode
    # ----------------------------------------------------------------------------------------------
    log_d ">> Entering debug mode"
    log_d "   In debug mode all text in yellow is debugging."
    debug_vars

    # Collect the profile selection from user
    # ----------------------------------------------------------------------------------------------
    PROFILES=()
    local profiles_dir="${SCRIPT_DIR}/profiles"
    local _profiles=($(echo $(find $profiles_dir -name "*.nix")))
    [ "x$DEFAULT" != "xy" ] && echo -e "\n${cyan}:: Select a deployment profile:${none}"
    local i=0
    for j in "${!_profiles[@]}"; do # ! means loop over indices instead of values
        local x=${_profiles[$j]}

        # Check if the profile contains the "# - Directly installable" string
        if grep -q "# - Directly installable" ${x} ; then
            x=${x//$profiles_dir\/}     # trim off the suffix dir
            x=${x//.nix}                # trim off the extension
            PROFILES+=($x)              # add to the final profiles list
            [ "x$DEFAULT" != "xy" ] && echo -e "   $((i+1))) ${cyan}${PROFILES[$i]}${none}"
            i=$((i+1))                  # increment i
        fi
    done
    if [ "x$DEFAULT" != "xy" ]; then
        getsel PROFILE $PROFILES
    fi

    # Collect install destination choice from user
    # ----------------------------------------------------------------------------------------------

    # Read in the potential destination disks details
    # [Major Device numers](https://www.kernel.org/doc/Documentation/admin-guide/devices.txt)
    # Filtering out: loop (7), floppy (2), CD-ROM (11, 15, 20, 24, 25, 26, 27, 28, 29, 30, 32)
    local excludes=2,7,11,15,20,24,25,26,27,28,29,30,32

    # ### Paramaters
    # -d    do not print holder devices or slaves
    # -n    do not print headings line
    # -e    exclude sepcified devices, loop(7), floppy(2)
    DISKS_DETAILED=$(lsblk -dn -e ${excludes} -o NAME,SIZE,MODEL,TYPE,HOTPLUG -x SIZE --json | \
        jq -rc '[.blockdevices[] | select(.type=="disk" and .hotplug!=true)]')

    # Get all the disks by name for selection
    DISKS=($(echo ${DISKS_DETAILED} | jq -rc '[.[].name] | map("/dev/"+.) | .[]'))

    # Sorted by size means the first, i.e. smallest, will likely be the boot drive
    DESTDEV=$(echo ${DISKS_DETAILED} | jq -rc '[.[].name] | map("/dev/"+.) | .[0]')

    # Print out the detected disks
    [ "x$DEFAULT" != "xy" ] && echo -e "\n${cyan}:: Select a disk as your install destination:${none}"
    local i=0
    echo $DISKS_DETAILED | jq -rc '.[]' | while read x; do
        i=$((i+1))
        local disk="/dev/$(echo $x | jq -r '.name')"
        local size="$(echo $x | jq -r '.size')"
        local model="$(echo $x | jq -r '.model')"
        [ "x$DEFAULT" != "xy" ] && echo -en "   ${i}) [${cyan}${disk}${none}](${cyan}${size}${none})"
        [ "x$DEFAULT" != "xy" ] && [ "$model" != "null" ] && echo -en " - ${model}"
        [ "x$DEFAULT" != "xy" ] && echo ""
    done

    # Get user choice
    if [ "x$DEFAULT" != "xy" ]; then
        getsel DESTDEV $DISKS
    fi

    [ "x${DEBUG}" == "x1" ] && log_d "User selected: $DESTDEV"

    # Determine the storage drive partition pattern.
    # ----------------------------------------------------------------------------------------------
    # https://wiki.archlinux.org/title/Device_file#Block_devices
    # Typically this is of the form device name followed by a number or device name
    # followed by a number with a 'p' prefix. I've only seen two different styles so far.
    #
    # Older style
    # - SCSI: /dev/sda        partition1: /dev/sda1
    # - QEMU: /dev/vda        partition1: /dev/vda1
    # Modern style
    # - NVMe: /dev/nvme0n1    partition1: /dev/nvme0n1p1
    # - MMC:  /dev/mmcblk0    partition1: /dev/mmcblk0p1

    # Match DESTDEV with /dev/sda and /dev/vda
    [ -z "${DESTDEV##*/dev/sd*}" ] || [ -z "${DESTDEV##*/dev/vd*}" ] && SCSI=1

    # Collect networking choices from user
    # ----------------------------------------------------------------------------------------------
    if [ "x$DEFAULT" != "xy" ]; then
        echo -e "\n${cyan}:: Configure networking:${none}"
        getinput HOSTNAME 'Enter hostname' $HOSTNAME
        getinput NETIP 'Enter static IP, e.g. 192.168.1.2/24' 'DHCP'
        if [ "x${NETIP}" != "xDHCP" ]; then
            getinput GATEWAY 'Enter gateway' $(echo $NETIP | awk -F. '{print $1"."$2"."$3".1"}')
        fi
        getinput ENABLE_BLUETOOTH 'Enter bluetooth state' 0
    fi

    # Collect time and date choices from user
    # ----------------------------------------------------------------------------------------------
    if [ "x$DEFAULT" != "xy" ]; then
        echo -e "\n${cyan}:: Configure time and date:${none}"
        getinput TIMEZONE 'Enter timezone' "$TIMEZONE"
        getinput TIMEDATE_SET "Change time ${cyan}$(date --iso-8601=seconds) UTC${none}" 'n'
        if [ "x$TIMEDATE_SET" == "xy" ]; then
            while true; do
                getinput TIMEDATE "Use ${cyan}ISO 8601 seconds${none} format" "$(date --iso-8601=seconds)"
                date -s "${TIMEDATE}" &>/dev/null
                [ $? -eq 0 ] && break
            done
        fi
    fi

    # Collect new user account choices from user
    # ----------------------------------------------------------------------------------------------
    if [ "x$DEFAULT" != "xy" ]; then
        echo -e "\n${cyan}:: Create new user account:${none}"
        getinput USER_NAME 'Enter new user name' $USER_NAME
        getinput USER_EMAIL 'Enter new user email' $USER_EMAIL
        while true; do
            getinput USER_PASS 'Enter new password' 'admin' 's'
            getinput USER_PASS2 'Enter password again' 'admin' 's'
            [ "x$USER_PASS" == "x$USER_PASS2" ] && break
            echo -e "   ${red}Passwords don't match, please try again${none}"
        done
    fi

    # Collect auto login choice from user
    # ----------------------------------------------------------------------------------------------
    if [ "x$DEFAULT" != "xy" ]; then
        if [ "x$AUTO_LOGIN" != "x1" ]; then
            getinput AUTO_LOGIN 'Do you want to auto login' 0
        fi
    fi

    # Start install
    # ----------------------------------------------------------------------------------------------
    echo
    header '-' "${cyan}" "Starting installation" 1
    echo -e ":: Options being used for installation"
    echo -e "   profile=${cyan}${PROFILE}${none}"
    echo -e "   hostname=${cyan}${HOSTNAME}${none}"
    echo -e "   networking=${cyan}${NETIP}${none}"
    echo -e "   user_name=${cyan}${USER_NAME}${none}"
    echo -e "   user_email=${cyan}${USER_EMAIL}${none}"
    if [ "x$DEFAULT" == "xy" ] || [ "x$DEFAULT_PASS" == "x$USER_PASS" ]; then
        echo -e "   user_pass=${cyan}${DEFAULT_PASS}${none}"
    else
        echo -e "   user_pass=${cyan}********${none}"
    fi
    echo -e "   timezone=${cyan}${TIMEZONE}${none}"
    echo -e "   auto_login=${cyan}${AUTO_LOGIN}${none}"
    echo -e "   dest_dev=${cyan}${DESTDEV}${none}"
    echo -e "   SCSI=${cyan}${SCSI}${none}"
    echo -e "   EFI=${cyan}${EFI}${none}"

    # Partition the target disk and mount it for deployment
    partition_and_mount_disk

    # Take user selections and apply to NixOS configuration
    config_system
}

# Build a minimal iso
# https://releases.nixos.org/
# https://discourse.nixos.org/t/nixos-reproducible-builds-minimal-installation-iso-successfully-independently-rebuilt/34756
build_iso()
{
    header '-' "${cyan}" "Building ISO" 1

    echo -e "\n${cyan}:: Stage iso.lock file:${none}"
    if [ -f iso.lock ]; then
        rm -f flake.lock
        cp iso.lock flake.lock
    fi

    echo -e "\n${cyan}:: Triggering nix iso build:${none}"
    nix build .#nixosConfigurations.iso.config.system.build.isoImage

    echo -e "\n${cyan}:: Save iso.lock file:${none}"
    if [ -f iso.lock ]; then
        cp flake.lock iso.lock
    fi
}


# Main entry point
# --------------------------------------------------------------------------------------------------
title()
{
    VERSION=0.0.1
    #VERSION=$(cat VERSION)
    header '=' "${cyan}" "Codified Likeness Utility - clu v${VERSION}" 1
    echo -e "${green}that is to say, build me a linux that i like${none}\n"
}
usage()
{
    title
    echo -e "Usage: ${cyan}./$(basename $0)${none} [options]\n"
    echo -e "Options:"
    echo -e "  -b COMPONENT     Build the given component"
    echo -e "  -i               Install the default system configuration" 
    echo -e "  -f FLAKE_URL     Install the given configuration flake at this URL"
    echo -e "  -t TEST_FUNC     Execute the given function for testing purposes"
    echo -e "  -h               Display usage help\n"
    echo -e "Examples:"
    echo -e "  ${green}Install the given configuration flake:${none} sudo ./${SCRIPT} -f https://github.com/phR0ze/nixos-config"
    echo -e "  ${green}Build the installer ISO:${none} ./${SCRIPT} -b iso"
    echo
    exit
}

# getopts notes
# - leading char <color> suppresses typical diagnostic messages
# - <colon> following flag means expect and argument
# - the \ on ? is required to make it work properly
while getopts ":b:f:it:h" opt; do
    case $opt in
        b) BUILD=$OPTARG;;
        f) FLAKE=$OPTARG;;
        i) INSTALL=1;;
        t) TEST=$OPTARG;;
        h) usage;;
        \?) echo -e "${red}Invalid option: ${none}-${OPTARG}\n"; usage;;
        :) echo -e "${red}Argument is required for option: ${none}-${OPTARG}\n"; usage;;
    esac
done
[ $(($OPTIND -1)) -eq 0 ] && usage
title

# Global setup
SCRIPT_DIR=$(cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &>/dev/null && pwd)

# Invoke the testing function if given
if [ ! -z ${TEST+x} ]; then
    header '-' "${yellow}" "Testing" 1
    eval $TEST
fi

# Build the given component
if [ ! -z ${BUILD+x} ]; then
    [ "${BUILD}" == "iso" ] && build_iso
fi

# Install the given configuration flake
if [ ! -z ${INSTALL+x} ] || [ ! -z ${FLAKE+x} ]; then
    installer
fi

# vim: ft=sh:ts=4:sw=4:sts=4
