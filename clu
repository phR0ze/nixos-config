#! /usr/bin/env bash

# MIT License
# Copyright (c) 2024 phR0ze
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# --------------------------------------------------------------------------------------------------
# Simple NixOS install automation
# 
# ## Features
# - Handles partitioning the disk in preparation for installation
# - Allows for customizing some common install settings
#   - hostname
# --------------------------------------------------------------------------------------------------
none="\e[m"
red="\e[1;31m"
cyan="\e[1;36m"
green="\e[1;32m"
yellow="\e[1;33m"

DEBUG=0

# Determine the script name and absolute root path of the project
SCRIPT=$(basename $0)
PROJECT_DIR=$(readlink -f $(dirname $BASH_SOURCE[0]))

# Print out a header
# --------------------------------------------------------------------------------------------------
# ### Params
# - $1 char to use for the separation line
# - $2 color to use
# - $3 header message
# - $4 double header or not 1/0
header()
{
    local char=$1
    local color=$2
    local msg=$3
    local double=$4

    # If the message has no color then colorize it
    [[ "${msg}" != *"\e[1"* ]] && msg="${color}${msg}${none}"

    echo
    [ "x$double" == "x1" ] && echo -e ${color}$_{1..80}'\b'"${char}"${none}
    echo -e ":: ${msg}"
    echo -e ${color}$_{1..80}'\b'"${char}"${none}
}

# Dump out debug variables
debug_vars()
{
    log_d ">> Debug variables"
    #log_d "   READ_MNT:  $READ_MNT"
}

# Common exit code for debug logging
exit_to_shell()
{
    debug_vars
    exit
}

check_status()
{
    if [ $? -ne 0 ]; then
        echo -e "${red}failed!${none}"
        exit_to_shell
    else
        [ "$1" != "nomsg" ] && echo -e "${green}success!${none}"
    fi
}

# Takes the value in $1 and prints it out if in debug mode
log_d()
{
    local msg=$1

    if [ "x${DEBUG}" == "x1" ]; then
        echo -e "${yellow}$msg${none}"
    fi
}

# Retrieve input from user
# Useful for making user selections
#
# Special commands:
# - "debug" will switch to debug mode
# - "exit" will exit to shell
getinput()
{
    local _result=$1                                # Return value target
    local input=$2                                  # User input value to prompt for
    local result=$3                                 # Default value to use if not set
    local silent=$4                                 # Don't echo when set

    # Notify user as directed
    echo -en "   ${input} (default=${cyan}${result}${none}): "

    # Defaulting settings is true then add a newline format nicely
    [ "x$DEFAULT" == "xy" ] && echo ''

    # Handle non default options 
    if [ "x$DEFAULT" == "xn" ]; then
        if [ $silent ]; then
            read -s value
            echo ''
        else
            read value
        fi

        # Handle debug user input
        [[ "$value" == *"debug"* ]] && DEBUG=1 && value=""
        [[ "$value" == *"exit"* ]] && exit_to_shell

        # Handle normal user input
        [ "x$value" != "x" ] && local result="$value"
    fi

    eval "$_result"="$result"
}

# Get the user's selection from a given list of options
# --------------------------------------------------------------------------------------------------
# ### Params
# - $1 return variable name to be set
# - $2 space delimited string of options
getsel()
{
    local _result=$1
    local options=$2
    local result=''

    # Count the numer of options available and set out_of_bounds one greater
    # as we are allowing valid selections to be 1 through n
    local out_of_bounds=0
    for x in $options; do
        local out_of_bounds=$(($out_of_bounds+1))
    done

    # Present options and retry if an invalid selection is given
    while true; do
        echo -en "   Enter a number (default=${cyan}1${none}): "
        [ "x$DEFAULT" == "xy" ] && echo '' || read choice
        [ "$choice" == "exit" ] && exit_to_shell
        [ "x$choice" == "x" ] && choice=1
        if [ $choice -gt 0 ] && [ $choice -le $out_of_bounds ]; then
            local result=$(echo $options | awk "{print \$$choice}")
            break
        else
            echo -e "   ${red}Invalid selection, please try again${none}"
       fi
    done

    eval $_result=$result
}

# Partition disk and mount for install at ${ROOT_MOUNT}
partition_and_mount_disk()
{
    header '-' "${cyan}" "Partitioning and mounting destination disk ${cyan}${DESTDEV}${none}..."

    # Wipe, partition and format disk
    #---------------------------------------------------------------------------
    echo -en ":: Disk ${cyan}${DESTDEV}${none} identified as destination disk..."
    [ "x${DESTDEV}" != "x" ]
    check_status

    echo -en ":: Destroying any magic strings and/or signatures on ${cyan}${DESTDEV}${none}..."
    wipefs --all --force ${DESTDEV} &>/dev/null
    check_status

    echo -en ":: Wiping partition table on ${cyan}${DESTDEV}${none}..."
    sgdisk --zap ${DESTDEV} &>/dev/null
    check_status

    # Set partition identifiers
    if [ "x${SCSI}" == "x1" ]; then
        PART_BOOT="${DESTDEV}1"
        PART_SWAP="${DESTDEV}2"
        PART_ROOT="${DESTDEV}3"
    else
        PART_BOOT="${DESTDEV}p1"
        PART_SWAP="${DESTDEV}p2"
        PART_ROOT="${DESTDEV}p3"
    fi

    # EFI: Create an ESP (EFI system partition) using linux code EF00
    # to act as a storage place for the EFI bootloaders to be launched by the UEFI firmware.
    # https://wiki.archlinux.org/index.php/EFI_System_Partition#Create_the_partition
    if [ "x${EFI}" == "x1" ]; then
        echo -en ":: Creating ${cyan}${PART_BOOT}${none} as ${cyan}ESP boot partition${none}..."
        sgdisk -n 0:0:+512M -t 0:EF00 -c 0:"EFI system" ${DESTDEV} &>/dev/null
        check_status

        echo -en ":: Formatting ${cyan}${PART_BOOT}${none} (ESP) as ${cyan}FAT32${none}..."
        mkfs.vfat -n "BOOT" ${PART_BOOT} &>/dev/null
        check_status

    # BIOS: Create a BIOS boot partition EF02
    else
        echo -en ":: Creating ${cyan}${PART_BOOT}${none} as ${cyan}BIOS boot partition${none}..."
        sgdisk -n 0:0:+2M -t 0:EF02 -c 0:"BIOS system" ${DESTDEV} &>/dev/null
        check_status
    fi

    # Create SWAP partition 8200
    echo -en ":: Creating ${cyan}${PART_SWAP}${none} as ${cyan}Linux swap partition${none}..."
    sgdisk -n 0:0:+4G -t 0:8200 -c 0:"Linux swap" ${DESTDEV} &>/dev/null
    check_status

    # Create root partition 8300
    echo -en ":: Creating ${cyan}${PART_ROOT}${none} as ${cyan}Linux filesystem partition${none}..."
    sgdisk -n 0:0:0 -t 0:8300 -c 0:"Linux filesystem" ${DESTDEV} &>/dev/null
    check_status

    # Set boot flag for device
    echo -en ":: Setting boot flag on ${cyan}${DESTDEV}${none}..."
    sgdisk ${DESTDEV} --attributes=3:set:2 &>/dev/null
    check_status

    # Configure swap partition
    echo -en ":: Formatting ${cyan}${PART_SWAP}${none} as ${cyan}swap${none}..."
    mkswap -L SWAP ${PART_SWAP} &>/dev/null
    check_status
    echo -en ":: Starting swap on ${cyan}${PART_SWAP}${none}..."
    swapon ${PART_SWAP} &>/dev/null
    check_status

    # mkfs.ext4 option descriptions
    # -F            force creation even if some params don't make sense
    # -L            set volume name to well known label used by bootloaders
    # -m 0          don't reserve blocks for super user daemons
    # -q            run in quiet mode for scripts
    echo -en ":: Formatting ${cyan}${PART_ROOT}${none} as ${cyan}ext4${none}..."
    mkfs.ext4 -F -m 0 -q -L ROOT ${PART_ROOT} &>/dev/null
    check_status

    # Mount root as ROOT_MOUNT and disable access time writes (speeds things up)
    echo -en ":: Mounting ${cyan}${PART_ROOT}${none} as ${cyan}${ROOT_MOUNT}${none}..."
    mount -o noatime ${PART_ROOT} ${ROOT_MOUNT} &>/dev/null
    check_status

    # UEFI: boot partition needs to be mounted over the root at /boot to capture the Linux
    # standard boot file install e.g. kernel and initramfs. We keep them on the same partition
    # as the EFI/BOOT/BOOTX64.efi as EFI can't mount a ext4 filesystem.
    if [ "x${EFI}" == "x1" ]; then
        echo -en ":: Mounting ${cyan}${PART_BOOT}${none} (ESP) as ${cyan}${ROOT_MOUNT}/boot${none}..."
        mkdir -p ${ROOT_MOUNT}/boot
        mount ${PART_BOOT} ${ROOT_MOUNT}/boot &>/dev/null
        check_status
    fi
    # BIOS: boot partition shouldn't be formatted or mounted in this case as its just for the MBR
}

config_system()
{
    # Clone the flake
    #-----------------------------------------------------------------------------------------------
    NIXOS_CONFIG="${ROOT_MOUNT}/etc/nixos"
    header '-' "${cyan}" "Cloning flake locally at ${cyan}${NIXOS_CONFIG}${none}"
    git clone ${FLAKE} ${NIXOS_CONFIG}

    # Generate the NixOS configuration files
    # This must be done after the disk partioning so that the system picks up the new partitions
    #-----------------------------------------------------------------------------------------------
    header '-' "${cyan}" "Generating NixOS configurations files at ${cyan}${NIXOS_CONFIG}${none}"
    nixos-generate-config --root ${ROOT_MOUNT}
    check_status

    # Modules must be at least staged for the flake to recognize them
    pushd ${NIXOS_CONFIG}
    git add hardware-configuration.nix
    popd

    # Extract the current NIXOS version from teh generated configuration.nix file
    NIXOS_VER==$(sed -n 's|^\s*system.stateVersion\s*=\s*"\(.*\)";.*|\1|p' "${NIXOS_CONFIG}/configuration.nix")
    echo -e ":: NIXOS target version: ${cyan}${NIXOS_VER}${none}"
    check_status
    rm -f "${NIXOS_CONFIG}/configuration.nix" # clean up

    # Configuring the root user
    #-----------------------------------------------------------------------------------------------
    # The pass here is intentially weird in the default case to be printable
    local pass=""
    [ "x$DEFAULT" == "xy" ] && pass=" (default: ${cyan}${DEFAULT_PASS}${none})"

    # Execute the NixOS install
    #-----------------------------------------------------------------------------------------------
    nixos-install --no-root-passwd --no-channel-copy --flake "${NIXOS_CONFIG}#default"

    #echo -e "\n:: Configuring root user..."
    #separator '-' "${cyan}"

    # Note: the new pam rules require SHA512 encryption else first login will require reset
    #echo -en ":: Setting root user password${pass}..."
    #chroot ${ROOT_MOUNT} /bin/bash -c "echo 'root:${PASS}' | chpasswd -c SHA512"
    #sed -i -e 's/^PermitRootLogin.*/PermitRootLogin yes/' "${CONFIG}"
    #check_status

#    echo -en ":: Copying skel configs to root user..."
#    chroot ${ROOT_MOUNT} /bin/bash -c "shopt -s dotglob; cp -r /etc/skel/* /root"
#    check_status
#
#    # Configure general system settings
#    #---------------------------------------------------------------------------
#    echo -e "\n:: Configuring general system settings..."
#    separator '-' "${cyan}"
#
#    # Configure localization to US by default
#    LOCALE="en_US"
#    echo -en ":: Setting localization to ${cyan}${LOCALE}${none}..."
#    echo "LANG=${LOCALE}.UTF-8" > ${ROOT_MOUNT}/etc/locale.conf
#    echo "LANGUAGE=${LOCALE}.UTF-8" >> ${ROOT_MOUNT}/etc/locale.conf
#    echo "${LOCALE}.UTF-8 UTF-8" > ${ROOT_MOUNT}/etc/locale.gen
#    chroot ${ROOT_MOUNT} locale-gen &>/dev/null
#    check_status
#
#    # Configure time and date
#    #---------------------------------------------------------------------------
#    if [ "x$TIMEDATE_SET" == "xy" ]; then
#        local now=$(date --iso-8601=seconds)
#        echo -en ":: Set time and date to ${cyan}${now}${none}..."
#        chroot ${ROOT_MOUNT} date -s ${now} &>/dev/null
#        check_status
#    fi
#
#    echo -en ":: Setting timezone to ${cyan}${TIMEZONE}${none}..."
#    chroot ${ROOT_MOUNT} ln -sf /usr/share/zoneinfo/$TIMEZONE /etc/localtime &>/dev/null
#    check_status
#
#    echo -en ":: Set hwclock to system clock ${cyan}${TIMEDATE}${none}..."
#    chroot ${ROOT_MOUNT} hwclock --systohc &>/dev/null
#    check_status
#
#    # Configure networking
#    #---------------------------------------------------------------------------
#    echo -e "\n:: Configuring networking out of box experience..."
#    separator '-' "${cyan}"
#
#    echo -en ":: Setting hostname to ${cyan}${HOSTNAME}${none}..."
#    echo $HOSTNAME > "${ROOT_MOUNT}/etc/hostname"
#    check_status
#
#    if [ "x$ENABLE_BLUETOOTH" == "x1" ]; then
#        echo -en ":: Enabling Bluetooth..."
#        chroot ${ROOT_MOUNT} systemctl enable bluetooth &>/dev/null
#        check_status
#    fi
#
#    # Configure DHCP LAN always as a fall back with a lower priority than static
#    netconf="${ROOT_MOUNT}/etc/NetworkManager/system-connections/dhcp"
#    echo -en ":: Configuring ${cyan}dhcp${none} networking..."
#    echo -e "[connection]\nid=Wired dhcp\nuuid=$(uuidgen)\ntype=ethernet\nautoconnect-priority=0\n" > $netconf
#    echo -e "[ipv4]\nmethod=auto\n" >> $netconf
#    echo -e "[ipv6]\nmethod=disabled" >> $netconf
#    chmod 0600 $netconf
#    check_status
#
#    # Configure static LAN if set
#    if [ "x${NETIP}" != "xDHCP" ]; then
#        netconf="${ROOT_MOUNT}/etc/NetworkManager/system-connections/static"
#        echo -en ":: Configuring ${cyan}static${none} networking..."
#        echo -e "[connection]\nid=Wired static\nuuid=$(uuidgen)\ntype=ethernet\nautoconnect-priority=1\n" > $netconf
#        echo -e "[ipv4]\nmethod=manual\naddress=${NETIP}\ngateway=${GATEWAY}\ndns=${DNS1};${DNS2}\n" >> $netconf
#        echo -e "[ipv6]\nmethod=disabled" >> $netconf
#        chmod 0600 $netconf
#        check_status
#    fi
#
#    # Configure wireless
#    netconf="${ROOT_MOUNT}/etc/systemd/network/30-wireless.network"
#    echo -en ":: Configuring ${cyan}dhcp wireless${none} networking..."
#    echo -e "[Match]\nName=wl*\n" > $netconf
#    echo -e "[Network]\nDHCP=ipv4\nIPForward=kernel\n" >> $netconf
#    echo -e "[DHCP]\nRouteMetric=20\nUseDomains=true" >> $netconf
#    check_status
#
#    # Configure root access for sshd if default deployment
#    if [ -e "${ROOT_MOUNT}/etc/ssh/sshd_config" ]; then
#        if [ "x$DEFAULT" == "xy" ]; then
#            echo -en ":: Enable sshd root access for ${cyan}auto default${none} deployment..."
#            sed -i -e 's/^PermitRootLogin.*/PermitRootLogin yes/' "${ROOT_MOUNT}/etc/ssh/sshd_config"
#            check_status
#        fi
#    fi
#
#    # Configuring the new user
#    #---------------------------------------------------------------------------
#    echo -e "\n:: Configuring new user ${cyan}${USER}${none}..."
#    separator '-' "${cyan}"
#
#    echo -en ":: Creating user group ${cyan}${USER}${none}..."
#    chroot ${ROOT_MOUNT} groupadd ${USER}
#    check_status
#
#    # Filter groups down to just those that exist
#    local groups=""
#    for x in ${GROUPS//,/ }; do
#        if [ $(grep -E "^$x:" ${ROOT_MOUNT}/etc/group) ]; then
#            [ $groups ] && groups="${groups},${x}" || groups="${x}"
#        fi
#    done
#
#    echo -en ":: Creating user ${cyan}${USER}${none} with groups ${cyan}${groups}${none}..."
#    chroot ${ROOT_MOUNT} useradd -m -g ${USER} -G ${groups} -s /bin/bash ${USER}
#    check_status
#
#    # Note the new pam rules require SHA512 encryption else first login will require reset
#    echo -en ":: Setting user password${pass}..."
#    chroot ${ROOT_MOUNT} /bin/bash -c "echo '${USER}:${PASS}' | chpasswd -c SHA512"
#    check_status
#
#    echo -en ":: Adding new user to sudoers list..."
#    chroot ${ROOT_MOUNT} /bin/bash -c "echo '${USER} ALL=(ALL) NOPASSWD: ALL' >> /etc/sudoers"
#    check_status
#
#    # Autologin if lxdm exists and parameter is set
#    if [ -e "${ROOT_MOUNT}/etc/lxdm/lxdm.conf" ]; then
#        if [ "x$AUTOLOGIN" == "x1" ]; then
#            echo -en ":: Enable autologin for LXDM..."
#            sed -i -e "s/^#\s*autologin=.*/autologin=${USER}/" "${ROOT_MOUNT}/etc/lxdm/lxdm.conf"
#            check_status
#            touch "${ROOT_MOUNT}/etc/lxdm/lxdm.conf_persist"
#        fi
#    fi
}

# Start the install wizard
# --------------------------------------------------------------------------------------------------
installer()
{
    SCSI=0
    DEFAULT='n'
    TIMEZONE='America/Boise'
    NETIP='DHCP'
    HOSTNAME='nixos'
    USER='admin'
    PASS='admin'
    DEFAULT_PASS='admin'
    ROOT_MOUNT='/mnt'

    # Detect EFI supported system
    [ -d /sys/firmware/efi ] && EFI=1 || EFI=0

    # Determine if this is a default deployment
    # ----------------------------------------------------------------------------------------------
    echo -e "${cyan}:: Automatically deploy with defaults?${none}"
    getinput DEFAULT 'Use automatic mode with defaults' 'n'
    if [ "x$DEFAULT" == "xy" ]; then
        AUTOLOGIN=1
    fi

    # Drop out debug variables if in debug mode
    # ----------------------------------------------------------------------------------------------
    log_d ">> Entering debug mode"
    log_d "   In debug mode all text in yellow is debugging."
    debug_vars

    # Collect install destination choice from user
    # ----------------------------------------------------------------------------------------------

    # Read in the potential destination disks details
    # [Major Device numers](https://www.kernel.org/doc/Documentation/admin-guide/devices.txt)
    # Filtering out: loop (7), floppy (2), CD-ROM (11, 15, 20, 24, 25, 26, 27, 28, 29, 30, 32)
    local excludes=2,7,11,15,20,24,25,26,27,28,29,30,32

    # ### Paramaters
    # -d    do not print holder devices or slaves
    # -n    do not print headings line
    # -e    exclude sepcified devices, loop(7), floppy(2)
    DISKS_DETAILED=$(lsblk -dn -e ${excludes} -o NAME,SIZE,MODEL,TYPE,HOTPLUG -x SIZE --json | \
        jq -rc '[.blockdevices[] | select(.type=="disk" and .hotplug!=true)]')

    # Get all the disks by name for selection
    DISKS=$(echo ${DISKS_DETAILED} | jq -rc '[.[].name] | map("/dev/"+.) | .[]')

    # Sorted by size means the first, i.e. smallest, will likely be the boot drive
    DESTDEV=$(echo ${DISKS_DETAILED} | jq -rc '[.[].name] | map("/dev/"+.) | .[0]')

    # Print out the detected disks
    echo -e "\n${cyan}:: Select a disk as your install destination:${none}"
    local i=0
    echo $DISKS_DETAILED | jq -rc '.[]' | while read x; do
        i=$((i+1))
        local disk="/dev/$(echo $x | jq -r '.name')"
        local size="$(echo $x | jq -r '.size')"
        local model="$(echo $x | jq -r '.model')"
        echo -en "   ${i}) [${cyan}${disk}${none}](${cyan}${size}${none})"
        [ "$model" != "null" ] && echo -en " - ${model}"
        echo ""
    done

    # Get user choice
    if [ "x$DEFAULT" != "xy" ]; then
        getsel DESTDEV "$DISKS"
    fi

    [ "x${DEBUG}" == "x1" ] && log_d "User selected: $DESTDEV"

    # Determine the storage drive partition pattern.
    # ----------------------------------------------------------------------------------------------
    # https://wiki.archlinux.org/title/Device_file#Block_devices
    # Typically this is of the form device name followed by a number or device name
    # followed by a number with a 'p' prefix. I've only seen two different styles so far.
    #
    # Older style
    # - SCSI: /dev/sda        partition1: /dev/sda1
    # - QEMU: /dev/vda        partition1: /dev/vda1
    # Modern style
    # - NVMe: /dev/nvme0n1    partition1: /dev/nvme0n1p1
    # - MMC:  /dev/mmcblk0    partition1: /dev/mmcblk0p1

    # Match DESTDEV with /dev/sda and /dev/vda
    [ -z "${DESTDEV##*/dev/sd*}" ] || [ -z "${DESTDEV##*/dev/vd*}" ] && SCSI=1

    # Collect networking choices from user
    # ----------------------------------------------------------------------------------------------
    if [ "x$DEFAULT" != "xy" ]; then
        echo -e "\n${cyan}:: Configure networking:${none}"
        getinput HOSTNAME 'Enter hostname' $HOSTNAME
        getinput NETIP 'Enter static IP, e.g. 192.168.1.2/24' 'DHCP'
        if [ "x${NETIP}" != "xDHCP" ]; then
            getinput GATEWAY 'Enter gateway' $(echo $NETIP | awk -F. '{print $1"."$2"."$3".1"}')
        fi
        getinput ENABLE_BLUETOOTH 'Enter bluetooth state' 0
    fi

    # Collect time and date choices from user
    # ----------------------------------------------------------------------------------------------
    if [ "x$DEFAULT" != "xy" ]; then
        echo -e "\n${cyan}:: Configure time and date:${none}"
        getinput TIMEZONE 'Enter timezone' "$TIMEZONE"
        getinput TIMEDATE_SET "Change time ${cyan}$(date --iso-8601=seconds) UTC${none}" 'n'
        if [ "x$TIMEDATE_SET" == "xy" ]; then
            while true; do
                getinput TIMEDATE "Use ${cyan}ISO 8601 seconds${none} format" "$(date --iso-8601=seconds)"
                date -s "${TIMEDATE}" &>/dev/null
                [ $? -eq 0 ] && break
            done
        fi
    fi

    # Collect new user account choices from user
    # ----------------------------------------------------------------------------------------------
    if [ "x$DEFAULT" != "xy" ]; then
        echo -e "\n${cyan}:: Create new user account:${none}"
        getinput USER 'Enter new username' $USER
        while true; do
            getinput PASS 'Enter new password' 'admin' 1
            getinput PASS2 'Enter password again' 'admin' 1
            [ "x$PASS" == "x$PASS2" ] && break
            echo -e "   ${red}Passwords don't match, please try again${none}"
        done
    fi

    # Collect autologin choice from user
    # ----------------------------------------------------------------------------------------------
    if [ "x$DEFAULT" != "xy" ]; then
        if [ "x$AUTOLOGIN" != "x1" ]; then
            getinput AUTOLOGIN 'Enter autologin' 0
        fi
    fi

    # Start install
    # ----------------------------------------------------------------------------------------------
    header '-' "${cyan}" "Starting installation" 1
    echo -e ":: Options being used for installation"
    echo -e "   hostname=${cyan}${HOSTNAME}${none}"
    echo -e "   networking=${cyan}${NETIP}${none}"
    echo -e "   user=${cyan}${USER}${none}"
    if [ "x$DEFAULT" == "xy" ] || [ "x$DEFAULT_PASS" == "x$PASS" ]; then
        echo -e "   pass=${cyan}${DEFAULT_PASS}${none}"
    else
        echo -e "   pass=${cyan}********${none}"
    fi
    echo -e "   timezone=${cyan}${TIMEZONE}${none}"
    echo -e "   autologin=${cyan}${AUTOLOGIN}${none}"
    echo -e "   dest_dev=${cyan}${DESTDEV}${none}"
    echo -e "   SCSI=${cyan}${SCSI}${none}"
    echo -e "   EFI=${cyan}${EFI}${none}"

    # Partition the target disk and mount it for deployment
    partition_and_mount_disk

    # Take user selections and apply to NixOS configuration
    config_system
}

# Build a minimal iso
# https://releases.nixos.org/
# https://discourse.nixos.org/t/nixos-reproducible-builds-minimal-installation-iso-successfully-independently-rebuilt/34756
build_iso()
{
    header '-' "${cyan}" "Building ISO" 1

    echo -e "\n${cyan}:: Stage iso.lock file:${none}"
    if [ -f iso.lock ]; then
        rm -f flake.lock
        cp iso.lock flake.lock
    fi

    echo -e "\n${cyan}:: Triggering nix iso build:${none}"
    nix build .#nixosConfigurations.iso.config.system.build.isoImage
}


# Main entry point
# --------------------------------------------------------------------------------------------------
title()
{
    VERSION=0.0.1
    #VERSION=$(cat VERSION)
    header '=' "${cyan}" "Codified Likeness Utility - clu v${VERSION}" 1
    echo -e "${green}that is to say, build me a linux that i like${none}\n"
}
usage()
{
    title
    echo -e "Usage: ${cyan}./$(basename $0)${none} [options]\n"
    echo -e "Options:"
    echo -e "  -b COMPONENT     Build the given component"
    echo -e "  -i               Install the default system configuration" 
    echo -e "  -f FLAKE_URL     Install the given configuration flake at this URL"
    echo -e "  -t TEST_FUNC     Execute the given function for testing purposes"
    echo -e "  -h               Display usage help\n"
    echo -e "Examples:"
    echo -e "  ${green}Install the given configuration flake:${none} sudo ./${SCRIPT} -f https://github.com/phR0ze/nixos-config"
    echo -e "  ${green}Build the installer ISO:${none} ./${SCRIPT} -b iso"
    echo
    exit
}

# getopts notes
# - leading char <color> suppresses typical diagnostic messages
# - <colon> following flag means expect and argument
# - the \ on ? is required to make it work properly
while getopts ":b:f:it:h" opt; do
    case $opt in
        b) BUILD=$OPTARG;;
        f) FLAKE=$OPTARG;;
        i) FLAKE=https://github.com/phR0ze/nixos-config;;
        t) TEST=$OPTARG;;
        h) usage;;
        \?) echo -e "${red}Invalid option: ${none}-${OPTARG}\n"; usage;;
        :) echo -e "${red}Argument is required for option: ${none}-${OPTARG}\n"; usage;;
    esac
done
[ $(($OPTIND -1)) -eq 0 ] && usage
title

# Invoke the testing function if given
if [ ! -z ${TEST+x} ]; then
    eval $TEST
fi

# Build the given component
if [ ! -z ${BUILD+x} ]; then
    [ "${BUILD}" == "iso" ] && build_iso
fi

# Install the given configuration flake
[ ! -z ${FLAKE+x} ] && installer

# vim: ft=sh:ts=4:sw=4:sts=4
