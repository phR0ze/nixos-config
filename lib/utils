#!/usr/bin/env bash

# Utility code
# 
# ## Features
#
# --------------------------------------------------------------------------------------------------
none="\e[m"
red="\e[1;31m"
cyan="\e[1;36m"
green="\e[1;32m"
yellow="\e[1;33m"

# Temporary file for reading command errors
ERRFILE=/tmp/clu.err

# Detect if the current directory is a nixos-config directory
# --------------------------------------------------------------------------------------------------
# Returns 0 on true or 1 on false; ugh not intuitive
utils::cwd_is_nixos_config()
{
    [[ ! -e "${CONFIG_DIR}/base.nix" || ! -e "${CONFIG_DIR}/base.lock" ]]
}

# Process global arguments
# --------------------------------------------------------------------------------------------------
utils::process_args()
{
    ARGS=("$@"); CLEAN=0; QUIET=0; DEBUG=0; TEST=0; INSTALL=0; IMPURE=""; TRACE=""; SUDO="";

    # Track removing used args if not sudo or sudo already processed
    [[ "x${SUDO_USER}" == "x" || "${ARGS[0]}" == "--as-user" ]] && _remove=1 || _remove=0

    # Process the args
    for i in "${!ARGS[@]}"; do
        if [[ "${ARGS[i]}" == "install" ]]; then
            INSTALL=1 # don't unset we'll need this later
        elif [[ "${ARGS[i]}" == "--debug" ]]; then
            [ $_remove -eq 1 ] && unset 'ARGS[i]'
            LOG_LEVEL="debug" && _log_level=$_debug
            DEBUG=1
            TRACE="--show-trace"
        elif [[ "${ARGS[i]}" == "--test" ]]; then
            [ $_remove -eq 1 ] && unset 'ARGS[i]'
            TEST=1
            LOG_LEVEL="debug" && _log_level=$_debug
            DEBUG=1
            TRACE="--show-trace"
        elif [[ "${ARGS[i]}" == "-c" || "${ARGS[i]}" == "--clean" ]]; then
            [ $_remove -eq 1 ] && unset 'ARGS[i]'
            CLEAN=1
        elif [[ "${ARGS[i]}" == "--impure" ]]; then
            [ $_remove -eq 1 ] && unset 'ARGS[i]'
            IMPURE="--impure"
        elif [[ "${ARGS[i]}" == "-q" || "${ARGS[i]}" == "--quiet" ]]; then
            [ $_remove -eq 1 ] && unset 'ARGS[i]'
            QUIET=1 && LOG_LEVEL="error" && _log_level=$_error
        fi
    done
    log::d "ARGS: $@"
    log::d "CLEAN=$CLEAN; QUIET=$QUIET; DEBUG=$DEBUG; TEST=$TEST; IMPURE=$IMPURE; TRACE=$TRACE; INSTALL=$INSTALL; SUDO=$SUDO"

    # Now clean out the consumed arguments
    ARGS=("${ARGS[@]}")
}

# Handle configuring the root and root or sudo permissions
# --------------------------------------------------------------------------------------------------
# - ROOT_DIR is meant to change based on where the deployment is being run from
#   in a normal system you'd use /etc/nixos for config and thus root is ``
# - CONFIG_DIR is based on the configurable ROOT_DIR for is by default /etc/nixos for a normal system
#   /mnt/etc/nixos for an installation or the current directory
utils::handle_root()
{
    ROOT_DIR=""
    if [[ $INSTALL -eq 1 ]]; then
        ROOT_DIR="/mnt"
        CONFIG_DIR="${ROOT_DIR}/etc/nixos"
    else
        CONFIG_DIR="$(pwd)"

        # if the local dir is not a valid nixos-config and we have a global clu then use the sytem 
        # config. this will prioritize the local configuration if its valid
        if [[ $(utils::cwd_is_nixos_config) -eq 1 && "${SCRIPT_DIR}" == "/nix/store"* ]]; then
            CONFIG_DIR="/etc/nixos"
        fi
    fi

    # Check if the target CONFIG_DIR is owned by root
    if [[ "$(stat -c %U "$CONFIG_DIR")" == "root" || "${INSTALL}" -eq 1 ]]; then
        log::d "Handling root owned CONFIG_DIR=$CONFIG_DIR"
        SUDO="sudo";
    else
        log::d "Handling user owned CONFIG_DIR=$CONFIG_DIR"
    fi

    if [[ "x${SUDO_USER}" == "x" ]]; then
        log::d "Skipping sudo privilege drop..."
        return
    fi

    # Protect against looping with sentinel
    if [[ "${ARGS[0]}" != "--as-user" ]]; then

        # First bail if using root user directly
        if [[ $EUID -eq 0 && "x${SUDO_USER}" == "x" ]]; then
            log::ls "${red}Error: root user detected without $SUDO_USER set!${none}"
            log::ls "${yellow}Run with user that has passwordless sudo privileges or with sudo${none}"
            exit 1
        fi

        # Next set $USER correctly and drop elevated privileges
        log::ls "Dropping root privileges..."
        USER="$SUDO_USER"

        # exec      gets rid of the original sudo shell
        # sudo -u   runs new shell as non root user
        # $0        original target
        # --as-user sentinel to avoid looping
        # $@        original params
        exec sudo -u "$USER" -- bash "$0" --as-user "${ARGS[@]}"
    else
        # Drop the sentinel so $ARGS contains only original args
        unset 'ARGS[0]'
        ARGS=("${ARGS[@]}")
        log::d "Drop --as-user sentinel ARGS: ${ARGS[@]}"
    fi
}

# Decrypt all encrypted files recursively in the current configuration directory
# --------------------------------------------------------------------------------------------------
# ### Params
# - $1 directory to recursively check
#
# ### Examples
# utils::decrypt "$CONFIG_DIR"
# --------------------------------------------------------------------------------------------------
utils::decrypt()
{
  local target="$1"
  local dir filename name ext decrypted encrypted encrypted_files decrypted_files

  mapfile -d '' -t encrypted_files < <(find "$target" -type f -name "*.enc.*" -print0)
  for encrypted in "${encrypted_files[@]}"; do
    log::d "Decrypting ${cyan}${encrypted}${none}"
    dir="${encrypted%/*}"               # get the diretory name
    filename="${encrypted##*/}"         # get the full file name
    name="${filename%%.*}"              # trim off the file extension
    ext="${filename##*.}"               # trim off the prefix including the '.'
    decrypted="$dir/${name}.dec.${ext}" # construct the decrypted file's name
    decrypted_files+=("$decrypted")     # add it to the decrypted array

    # Execute decryption for target
    $SUDO sops --decrypt "$encrypted" > "$decrypted"
  done

  # Now add them all to git
  #git add -- "${files[@]}"
}

# Add all decrypted files to git
# --------------------------------------------------------------------------------------------------
# - assumes the caller has used pushd to switch directories for git to work correctly
#
# ### Params
# - $1 directory to recursively check
#
# ### Examples
# utils::add_decrypted_to_git "$CONFIG_DIR"
# --------------------------------------------------------------------------------------------------
utils::add_decrypted_to_git()
{
  local target="$1"
  log::d "Adding decrypted files to git from ${cyan}${target}${none}"
  mapfile -d '' -t decrypted_files < <(find "$target" -type f -name "*.dec.*" -print0)
  $SUDO git add -f -- "${decrypted_files[@]}"
}

# Remove decrypted from git and disk
# --------------------------------------------------------------------------------------------------
# - assumes the caller has used pushd to switch directories for git to work correctly
#
# ### Params
# - $1 directory to recursively check
#
# ### Examples
# utils::remove_decrypted_from_git "$CONFIG_DIR"
# --------------------------------------------------------------------------------------------------
utils::remove_decrypted()
{
  local target="$1"
  mapfile -d '' -t decrypted_files < <(find "$target" -type f -name "*.dec.*" -print0)
  if [ ${#decrypted_files[@]} -ne 0 ]; then
    log::d "Removing decrypted files from git for ${cyan}${target}${none}"
    $SUDO git restore --staged -- "${decrypted_files[@]}" &>/dev/null || true
  fi

  # Always attempt to remove the files
  log::d "Removing decrypted files from disk for ${cyan}${target}${none}"
  $SUDO rm -f -- "${decrypted_files[@]}"
}

# Execute the given command with conditional redirect for cleaner output while allowing for 
# --------------------------------------------------------------------------------------------------
# debugging if the --debug flag is given which sets $DEBUG
# - runs the given args as pass through
# --------------------------------------------------------------------------------------------------
utils::run()
{
    if [ $DEBUG -eq 0 ]; then
        "$@" &>/dev/null
    else
        "$@"
    fi
}

# Determine if the system is a legacy MBR system
# --------------------------------------------------------------------------------------------------
# - Modern systems from 2012 support the GPT partition table supporting disks >= 2TB
# - Legacy systems with older BIOS versions require a MBR partition table and disks <= 2TB
# --------------------------------------------------------------------------------------------------
utils::get_mbr_efi_vars()
{
    # Check if the system supports EFI
    [ -d /sys/firmware/efi ] && EFI=1 || EFI=0

    # Check if the system requires legacy MBR support
    MBR=0
    if [[ $EFI -eq 0 && -f /sys/class/dmi/id/bios_date ]]; then
        local bios_year=$(awk -F'/' '{print $3}' /sys/class/dmi/id/bios_date) 
        if [ $bios_year -le 2012 ]; then
            MBR=1
            log::d "Legacy BIOS detected using ${cyan}MBR partition table${none}"
        fi
    fi
    if [ $MBR -eq 0 ]; then
        log::d "Newer BIOS/UEFI detected using ${cyan}GPT partition table${none}"
    fi
}

# Check if the given binary is installed
# --------------------------------------------------------------------------------------------------
# ### Params
# - $1 binary to check for
# - $2 message if the binary doesn't exist
#
# ### Examples
# utils::exists "nix-locate" "${cyan}nix-index${none} package must be installed"
# --------------------------------------------------------------------------------------------------
utils::exists()
{
    local target="$1"
    local msg="$2"

    if [ ! $(which "$target" 2>/dev/null) ]; then
        log::fatal "$msg"
    fi
}

# Common exit code for debug logging
utils::exit()
{
    exit
}

# Execute the given help function if the commands arguments contain help flags anywhere
# --------------------------------------------------------------------------------------------------
# ### Params
# - `zero` is a special indicator that zero args are expected and shouldn't fail
# - last argument should always be the usage function to run
#
# ### Examples
# utils::help "$@" update::usage
# --------------------------------------------------------------------------------------------------
utils::help()
{
    local args=($@)

    # Check for zero args
    local zero=0
    for x in ${args[@]}; do
      [[ "$x" == "zero" ]] && zero=1
    done
    if [ $zero -eq 0 ]; then
        if [[ ${#args[@]} -eq 1 ]]; then eval "${args[-1]}"; fi
    fi

    # Check for help anywhere in the args
    for x in ${args[@]}; do
      if [[ "$x" == "-h" || "$x" == "--help" ]]; then eval "${args[-1]}"; fi
    done
}

# Read user choice to continue or not
# --------------------------------------------------------------------------------------------------
utils::confirm_continue()
{
    echo -en "${yellow}continue [y/n]? ${none}" && read -n 1 confirm && echo
    if [[ "$confirm" != "y" ]]; then
        log::ls "${yellow}Aborting${none}"
        exit 1
    fi
}

# Read user choice from command line
# --------------------------------------------------------------------------------------------------
# ### Params
# - $1 return variable name to be set
# - $2 message to display to the user to prompt for read
# - $3 default value to use if no value was read
# - $4 if 's' don't echo result, if 'f' force answer from user
#
# Special commands:
# Instead of answering the read query the user can use these special commands to invoke debugging
# - "debug" will switch to debug mode
# - "exit" will exit to shell
# --------------------------------------------------------------------------------------------------
utils::read()
{
    DEFAULT="${DEFAULT:-n}"

    local _result=$1
    local msg=$2
    local result=$3
    local multi=$4

    # Notify user as directed
    if [[ "${result}" == "" ]]; then
        echo -en "   ${msg}: "
    else
        echo -en "   ${msg} (default=${cyan}${result}${none}): "
    fi

    # Defaulting settings is true then add a newline to format nicely
    if [[ "$multi" != "f" && "$DEFAULT" == "y" ]]; then
      echo
    fi

    # Handle non default options 
    if [[ "$multi" == "f" || "$DEFAULT" == "n" ]]; then
        if [ "$multi" == "s" ]; then
            read -s value
            echo
        else
            read value
        fi

        # Handle debug values
        [[ "$value" == *"debug"* ]] && DEBUG=1 && value=""
        [[ "$value" == *"exit"* ]] && utils::exit

        # Handle normal user read
        [ "x$value" != "x" ] && result="$value"
    fi

    # Needs the single quotes to tell it not to treat it as a command
    eval "$_result"="'$result'"
}

# Get the user's selection from an array of options
# --------------------------------------------------------------------------------------------------
# ### Params
# - $1 return variable name to be set
# - $2 array of options to select from
# --------------------------------------------------------------------------------------------------
utils::select()
{
    local _result=$1
    shift # Remove the first argument
    local options=($@)
    local result=''
    log::d "Selections: ${options[@]}"

    # Array length + 1 since we are starting with 1 rather than 0
    local out_of_bounds=$((${#options[@]}+1))
    log::d "Select out of bounds: $out_of_bounds"

    # Present options and retry if an invalid selection is given
    while true; do
        echo -en "   Enter your numbered selection (default=${cyan}1${none}): "
        [ "$DEFAULT" == "y" ] && echo || read choice
        [ "$choice" == "exit" ] && utils::exit
        [ "$choice" == "" ] && choice=1
        log::d "Choice: $choice"
        if [[ $choice -gt 0 && $choice -lt $out_of_bounds ]]; then
            choice=$((choice-1))
            local result=${options[$choice]}
            log::d "Selection: index=$choice, value=${result}"
            break
        else
            echo -e "   ${red}Invalid selection, please try again${none}"
        fi
    done

    # Needs the single quotes to tell it not to treat it as a command
    eval "$_result"="'$result'"
}

# Add padding to the given string
# --------------------------------------------------------------------------------------------------
# ### Params
# - $1 return variable name to be set
# - $2 string to pad
# - $3 pad char to use
# - $4 pad length including string length
# --------------------------------------------------------------------------------------------------
utils::pad_suffix()
{
    local _result="$1"
    local str="$2"
    local char="$3"
    local len=$4

    local i=$len
    while ((i-- > 0)); do
      str+="$char"
    done
    str="${str:0:${len}}"

    # Needs the single quotes to tell it not to treat it as a command
    eval "$_result"="'$str'"
}

# Replace the given value in the given file
# --------------------------------------------------------------------------------------------------
# ### Params
# - $1 optional 'sudo' arg
# - $2 file to target
# - $3 type of replacement [str | bool | int]
# - $4 value to search for
# - $5 value to replace with
# --------------------------------------------------------------------------------------------------
utils::replace()
{
    log::d "Replace ($#): $@"
    local _sudo=""
    local file kind target value

    if [[ "x$1" == "xsudo" ]]; then
        _sudo="sudo"
    fi
    shift # always shift one off as the white space gets interpreted as an arg

    file="$1"; kind="$2"; target="$3"; value="$4";
    log::d "Replace: file=$file; kind=$kind; target=$target; value=$value;"

    if [[ "x$kind" == "xbool" || "x$kind" == "xint" ]]; then
        ${_sudo} sed -i -e "s|\(^.*${target} = \).*\(;.*$\)|\1${value}\2|" "${file}"
    elif [ "x$kind" == "xstr" ]; then
        ${_sudo} sed -i -e "s|\(^.*${target} = \"\).*\(\";.*$\)|\1${value}\2|" "${file}"
    fi
}

# Builds on utils::replace to update an argument pair name=value
# --------------------------------------------------------------------------------------------------
# - $1 optional 'sudo' arg
# - $2 file to target
# - $3 the kind of value [str | bool | int]
# - $4 the name of the variable to change in the args file
# - $5 the value to set
# - $6 the value is a pair to split [ true ]
# --------------------------------------------------------------------------------------------------
utils::update()
{
    log::d "Update ($#): $@"
    local _sudo=""
    local file kind var value pair

    if [[ "x$1" == "xsudo" ]]; then
        _sudo="sudo"
    fi
    shift # always shift one off as the white space gets interpreted as an arg

    file="$1"; kind="$2"; var="$3"; value="$4"; pair="$5";
    log::d "Update: file=$file; kind=$kind; var=$var; value=$value; pair=$pair"

    # Parse the value from the pair, triming the prefix including the '='
    [[ "$pair" == "true" ]] && value="${value#*=}"

    # Update the value in the arg file
    log::ls "Updating ${file}: ${cyan}${var}${none} => ${cyan}${value}${none}"
    utils::replace "$_sudo" "$file" "${kind}" "${var}" "${value}"
}
