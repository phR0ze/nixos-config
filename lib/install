#!/usr/bin/env bash

# Installation code
# 
# ## Features
#
# --------------------------------------------------------------------------------------------------

# Usage for the install command and its sub commands
# --------------------------------------------------------------------------------------------------
install::usage()
{
    cat <<USAGE
Usage:
  install [COMMAND] [ARGS...] [OPTIONS]

Options:
  -h, --help        Print out usage

Commands:
  install [PATH]    Execute the installer with an optional alternate nixos-config destination
USAGE

    log::ln "\nExamples:"
    log::subln "Launch installer: ${green}sudo ./${SCRIPT} install${none}"
    log::subln "Launch installer with alternate nixos-config path: ${green}sudo ./${SCRIPT} install tmp${none}"
    echo
    exit
}

# Partition disk and mount for install at ${ROOT_DIR}
install::prepare_disk()
{
    log::header1 "Partitioning and mounting destination disk ${cyan}${DESTDEV}${none}..."

    # Set partition identifiers
    # - [GPT partitioning](https://nixos.org/manual/nixos/stable/#sec-installation-manual-partitioning-UEFI)
    if [[ $SCSI -eq 1 ]]; then
        PART_ROOT="${DESTDEV}1"
        PART_SWAP="${DESTDEV}2"
        PART_BOOT="${DESTDEV}3"
    else
        PART_ROOT="${DESTDEV}p1"
        PART_SWAP="${DESTDEV}p2"
        PART_BOOT="${DESTDEV}p3"
    fi

    # Wipe, partition and format disk
    # --------------------------------------------------------------------------
    log::ls "${red}WARNING this will DESTROY all data on disk:${none} ${cyan}${DESTDEV}${none}"
    utils::read DESTROY 'Do you wish to continue?' 'n' 'f'
    [[ "x${DESTROY}" != "xy" && "x${DESTROY}" != "xskip" ]] && exit
    [[ "x${DESTROY}" == "xskip" ]] && return
    echo

    # Check if we restarted and need to unmount first
    if [[ "$(mount | grep ${PART_ROOT})" != "" || "$(swapon --show)" != "" ]]; then
        log::ls -n "${cyan}Restart detected${none} - unmounting previous paritions..."
        swapoff ${PART_SWAP} &>/dev/null || true
        umount ${ROOT_DIR}/boot &>/dev/null || true
        umount ${ROOT_DIR} &>/dev/null || true
        log::status
    fi

    log::ls -n "Destroying any magic strings and/or signatures on ${cyan}${DESTDEV}${none}..."
    wipefs --all --force ${DESTDEV} &>/dev/null
    log::status

    log::ls -n "Wiping partition table on ${cyan}${DESTDEV}${none}..."
    sgdisk --zap ${DESTDEV} &>/dev/null
    log::status

    # Parted notes
    # - Parted interprets MiB and GiB notation as exact byte values and doesn't auto-align the 
    #   partitions causing failure.

    # Create the partition table type
    # - GPT is for UEFI or newer BIOS that support disks >= 2TB
    # - MBR is for legacy systems with BIOS 2012 or older
    if [ $MBR -eq 0 ]; then
        log::ls -n "Creating ${cyan}Modern GPT partition table${none}..."
        parted "${DESTDEV}" -- mklabel gpt &>/dev/null
        log::status
    else
        log::ls -n "Creating ${cyan}Legacy MBR partition table${none}..."
        parted "${DESTDEV}" -- mklabel msdos &>/dev/null
        log::status
    fi

    # (PART_ROOT i.e. #1) create the root partition 'Linux filesystem' type 8300 
    # - fills the disk except for the end where swap will live and the begining 512MB for boot
    if [ $MBR -eq 0 ]; then
        log::ls -n "Creating ROOT ${cyan}${PART_ROOT}${none} partition for ${cyan}GPT partition table${none}..."
        parted -s -a optimal "${DESTDEV}" -- mkpart primary ext4 512MB -5GB &>/dev/null
        log::status
    else
        log::ls -n "Creating ROOT ${cyan}${PART_ROOT}${none} partition for ${cyan}MBR partition table${none}..."
        parted -s -a optimal "${DESTDEV}" -- mkpart primary ext4 1MB -5GB &>/dev/null
        log::status
    fi

    # (PART_SWAP i.e. #2) create the SWAP partition 8200
    # - this is the same regardless of the partition table type
    log::ls -n "Creating ${cyan}${PART_SWAP}${none} as ${cyan}Linux swap partition${none}..."
    parted -s -a optimal "${DESTDEV}" -- mkpart primary linux-swap -5GB 100% &>/dev/null
    log::status
    log::ls -n "Formatting ${cyan}${PART_SWAP}${none} as ${cyan}swap${none}..."
    mkswap -L SWAP ${PART_SWAP} &>/dev/null
    log::status
    log::ls -n "Starting swap on ${cyan}${PART_SWAP}${none}..."
    swapon ${PART_SWAP} &>/dev/null
    log::status

    # (PART_BOOT i.e. #3) configure boot process for:
    # - EFI: Create an ESP (EFI system partition) using linux code EF00
    #   - to act as a storage place for the EFI bootloaders to be launched by the UEFI firmware.
    #   - https://wiki.archlinux.org/index.php/EFI_System_Partition#Create_the_partition
    # - GPT: modern BIOS need a partition EF02 created and GRUB will handle the rest
    # - MBR: legacy BIOS need the ROOT partition's to have a boot flag set
    if [ $EFI -eq 1 ]; then
        log::ls -n "Creating ${cyan}${PART_BOOT}${none} as ${cyan}ESP boot partition${none}..."
        parted -s -a optimal "${DESTDEV}" -- mkpart "ESP" fat32 1MB 512MB &>/dev/null
        log::status
        log::ls -n "Mark ${cyan}${PART_BOOT}${none} as ${cyan}ESP boot partition${none}..."
        parted "${DESTDEV}" -- set 3 esp on &>/dev/null
        log::status
        log::ls -n "Formatting ${cyan}${PART_BOOT}${none} (ESP) as ${cyan}FAT32${none}..."
        mkfs.vfat -n "BOOT" ${PART_BOOT} &>/dev/null
        log::status
    elif [ $MBR -eq 0 ]; then
        log::ls -n "Creating ${cyan}${PART_BOOT}${none} as ${cyan}BIOS boot partition${none}..."
        parted -s -a optimal "${DESTDEV}" -- mkpart "ESP" fat32 1MB 512MB &>/dev/null
        log::status
        log::ls -n "Setting boot flag ${cyan}${PART_BOOT}${none} for modern GPT..."
        parted "${DESTDEV}" -- set 1 bios_grub on &>/dev/null
        log::status
        # No need to format or mount this, GRUB will handle anything needed
    else
        log::ls -n "Setting boot flag ${cyan}${PART_ROOT}${none} for Legacy MBR..."
        parted "${DESTDEV}" -- set 1 boot on &>/dev/null
        log::status
    fi

    # Format the ROOT partition
    # mkfs.ext4 option descriptions
    # -F            force creation even if some params don't make sense
    # -L            set volume name to well known label used by bootloaders
    # -m 0          don't reserve blocks for root services
    # -q            run in quiet mode for scripts
    log::ls -n "Formatting ${cyan}${PART_ROOT}${none} as ${cyan}ext4${none}..."
    mkfs.ext4 -F -m 0 -q -L ROOT ${PART_ROOT} &>/dev/null
    log::status

    # Mount root as ROOT_DIR and disable access time writes (speeds things up)
    log::ls -n "Mounting ${cyan}${PART_ROOT}${none} as ${cyan}${ROOT_DIR}${none}..."
    mount -o noatime ${PART_ROOT} ${ROOT_DIR} &>/dev/null
    log::status

    # UEFI: boot partition needs to be mounted over the root at /boot to capture the Linux
    # standard boot file install e.g. kernel and initramfs. We keep them on the same partition
    # as the EFI/BOOT/BOOTX64.efi as EFI can't mount a ext4 filesystem.
    if [ $EFI -eq 1 ]; then
        log::ls -n "Mounting ${cyan}${PART_BOOT}${none} (ESP) as ${cyan}${ROOT_DIR}/boot${none}..."
        mkdir -p ${ROOT_DIR}/boot
        mount ${PART_BOOT} ${ROOT_DIR}/boot &>/dev/null
        log::status
    fi

    # $PART_BOOT i.e. BIOS boot partition doesn't need to be formatted or mounted as its just 
    # reserving space at the begining of the disk for the MBR to be installed into by GRUB.

    log::d "Leaving install::prepare_disk"
}

# Actual install of the system after configuration is in place
install::install_system()
{
    log::header1 "Installing NixOS based on the staged configuration"
    flake::stage_files "${MACHINE}" --install --no-trap

    # Run the installer: $CONFIG_DIR will be /mnt/etc/nixos unless testing
    log::ls "Launching installation with ${cyan}nixos-install${none}..."
    nixos-install --no-root-passwd --no-channel-copy --flake "${CONFIG_DIR}#target"
    if [ $? -ne 0 ]; then
        echo -e ":: ${red}Failure building the install flake${none}"
        echo -e "   1. Fix the flake issue at ${cyan}${CONFIG_DIR}${none}"
        echo -e "   2. Rerun: ${cyan}nixos-install --no-root-passwd --no-channel-copy --flake ${CONFIG_DIR}#target${none}"
    fi

    flake::unstage_files
    log::d "Leaving install::install_system"
}

# Create the new system's persistent configuration or stage the existing system
install::install_config()
{
    MACHINE="machines/$HOSTNAME"
    local machine_args="${MACHINE}/args.dec.json"
    log::header1 "Install system ${cyan}${MACHINE}${none}"

    # Create the new machine directory
    pushd "${CONFIG_DIR}" &>/dev/null
    mkdir -p "${MACHINE}"

    # Construct machines/$MACHINE/args.dec.json to be encrypted after install
    local args=$(jq -n '{}')

    # Convert general options to json
    log::ls -n "Staging ${cyan}hostname=${HOSTNAME}${none}..."
    args=$(echo "$args" | jq --arg k "hostname" --arg v "${HOSTNAME}" '. + {$k: $v}')
    log::status
    log::ls -n "Staging ${cyan}timezone=${TIMEZONE}${none}..."
    args=$(echo "$args" | jq --arg k "timezone" --arg v "${TIMEZONE}" '. + {$k: $v}')
    log::status
    local uuid="$(dbus-uuidgen)"
    log::ls -n "Staging ${cyan}id=${uuid}${none}..."
    args=$(echo "$args" | jq --arg k "id" --arg v "${uuid}" '. + {$k: $v}')
    log::status
    if [[ $EFI -eq 1 ]]; then
        log::ls -n "Staging ${cyan}efi=true${none}..."
        args=$(echo "$args" | jq --arg k "efi" --argjson v true '. + {$k: $v}')
        log::status
    else
        log::ls -n "Staging ${cyan}mbr=${DESTDEV}${none}..."
        args=$(echo "$args" | jq --arg k "mbr" --arg v "${DESTDEV}" '. + {$k: $v}')
        log::status
    fi

    log::ls -n "Staging ${cyan}nix.minVer=${NIXOS_VER}${none}..."
    args=$(echo "$args" | jq --arg k "nix.minVer" --arg v "${NIXOS_VER}" '($k | split(".")) as $p | setpath($p; $v)')
    log::status

    # Convert user options to json
    local pass="*******"
    [[ "x$DEFAULT" == "xy" ]] && pass="${DEFAULT_PASS}" || true
    log::ls -n "Staging ${cyan}user.fullname=${FULL_NAME}${none}..."
    args=$(echo "$args" | jq --arg k "user.fullname" --arg v "${FULL_NAME}" '($k | split(".")) as $p | setpath($p; $v)')
    log::status
    log::ls -n "Staging ${cyan}user.email=${USER_EMAIL}${none}..."
    args=$(echo "$args" | jq --arg k "user.email" --arg v "${USER_EMAIL}" '($k | split(".")) as $p | setpath($p; $v)')
    log::status
    log::ls -n "Staging ${cyan}user.name=${USER_NAME}${none}..."
    args=$(echo "$args" | jq --arg k "user.name" --arg v "${USER_NAME}" '($k | split(".")) as $p | setpath($p; $v)')
    log::status
    log::ls -n "Staging ${cyan}user.pass=${pass}${none}..."
    args=$(echo "$args" | jq --arg k "user.pass" --arg v "${USER_PASS}" '($k | split(".")) as $p | setpath($p; $v)')
    log::status
    log::ls -n "Staging ${cyan}user.group=${USER_NAME}${none}..."
    args=$(echo "$args" | jq --arg k "user.group" --arg v "${USER_NAME}" '($k | split(".")) as $p | setpath($p; $v)')
    log::status
    log::ls -n "Staging ${cyan}git.user=${GIT_USER}${none}..."
    args=$(echo "$args" | jq --arg k "git.user" --arg v "${GIT_USER}" '($k | split(".")) as $p | setpath($p; $v)')
    log::status
    log::ls -n "Staging ${cyan}git.email=${GIT_EMAIL}${none}..."
    args=$(echo "$args" | jq --arg k "git.email" --arg v "${GIT_EMAIL}" '($k | split(".")) as $p | setpath($p; $v)')
    log::status

    # Convert networking options to json
    NICS=($(ls /sys/class/net))
    log::ls -n "Staging ${cyan}net.nic0.name=${NICS[0]}${none}..."
    args=$(echo "$args" | jq --arg k "net.nic0.name" --arg v "${NICS[0]}" '($k | split(".")) as $p | setpath($p; $v)')
    log::status
    if [[ "x$SUBNET" != "x" ]]; then
        log::ls -n "Staging ${cyan}net.subnet=${SUBNET}${none}..."
        args=$(echo "$args" | jq --arg k "net.subnet" --arg v "${SUBNET}" '($k | split(".")) as $p | setpath($p; $v)')
        log::status
    fi
    if [[ "x$GATEWAY" != "x" ]]; then
        log::ls -n "Staging ${cyan}net.gateway=${GATEWAY}${none}..."
        args=$(echo "$args" | jq --arg k "net.gateway" --arg v "${GATEWAY}" '($k | split(".")) as $p | setpath($p; $v)')
        log::status
    fi
    if [[ "x$PRIMARY_DNS" != "x" ]]; then
        log::ls -n "Staging ${cyan}net.dns.primary=${PRIMARY_DNS}${none}..."
        args=$(echo "$args" | jq --arg k "net.dns.primary" --arg v "${PRIMARY_DNS}" '($k | split(".")) as $p | setpath($p; $v)')
        log::status
    fi
    if [[ "x$FALLBACK_DNS" != "x" ]]; then
        log::ls -n "Staging ${cyan}net.dns.fallback=${FALLBACK_DNS}${none}..."
        args=$(echo "$args" | jq --arg k "net.dns.fallback" --arg v "${FALLBACK_DNS}" '($k | split(".")) as $p | setpath($p; $v)')
        log::status
    fi
    if [[ "x$IP" != "xDHCP" ]]; then
        log::ls -n "Staging ${cyan}net.nic0.ip=${IP}${none}..."
        args=$(echo "$args" | jq --arg k "net.nic0.ip" --arg v "${IP}" '($k | split(".")) as $p | setpath($p; $v)')
        log::status
    fi
    if [[ "x$SUBNET" != "x" ]]; then
        log::ls -n "Staging ${cyan}net.nic0.subnet=${SUBNET}${none}..."
        args=$(echo "$args" | jq --arg k "net.nic0.subnet" --arg v "${SUBNET}" '($k | split(".")) as $p | setpath($p; $v)')
        log::status
    fi
    if [[ "x$GATEWAY" != "x" ]]; then
        log::ls -n "Staging ${cyan}net.nic0.gateway=${GATEWAY}${none}..."
        args=$(echo "$args" | jq --arg k "net.nic0.gateway" --arg v "${GATEWAY}" '($k | split(".")) as $p | setpath($p; $v)')
        log::status
    fi
    if [[ "x$PRIMARY_DNS" != "x" ]]; then
        log::ls -n "Staging ${cyan}net.nic0.dns.primary=${PRIMARY_DNS}${none}..."
        args=$(echo "$args" | jq --arg k "net.nic0.dns.primary" --arg v "${PRIMARY_DNS}" '($k | split(".")) as $p | setpath($p; $v)')
        log::status
    fi
    if [[ "x$FALLBACK_DNS" != "x" ]]; then
        log::ls -n "Staging ${cyan}net.nic0.dns.fallback=${FALLBACK_DNS}${none}..."
        args=$(echo "$args" | jq --arg k "net.nic0.dns.fallback" --arg v "${FALLBACK_DNS}" '($k | split(".")) as $p | setpath($p; $v)')
        log::status
    fi
    if [[ "x$BLUETOOTH" == "xy" ]]; then
        log::ls -n "Staging ${cyan}bluetooth=true${none}..."
        args=$(echo "$args" | jq --arg k "bluetooth" --argjson v true '. + {$k: $v}')
        log::status
    fi
    if [[ "x$AUTO_LOGIN" == "xy" ]]; then
        log::ls -n "Staging ${cyan}autologin=true${none}..."
        args=$(echo "$args" | jq --arg k "autologin" --argjson v true '. + {$k: $v}')
        log::status
    fi
    if [[ "x$NFS_SHARES" == "xy" ]]; then
        log::ls -n "Staging ${cyan}nfs.enable=true${none}..."
        args=$(echo "$args" | jq --arg k "nfs.enable" --argjson v true '($k | split(".")) as $p | setpath($p; $v)')
        log::status
    fi

    # Write out the file to machines/$HOSTNAME/configuration.nix
    log::ls -n "Generating ${MACHINE}/configuration.nix..."
    cat > "${MACHINE}/configuration.nix" <<EOF
{ config, pkgs, lib, args, f, ... }: with lib.types;
{
  imports = [ ./hardware-configuration.nix ../../${PROFILE} ];
  config = {
    machine.type.bootable = true;
  };
}
EOF
    log::status

    # Add the /mnt/etc/nixos/machines/$HOSTNAME/args.nix
    log::ls -n "Generating install time ${machine_args}..."
    echo "$args" | jq -r > "${machine_args}"
    log::status

    # Files must be at least git added for the flake to recognize them
    log::ls -n "Re-locate hardware config to ${MACHINE}/hardware-configuration.nix..."
    mv hardware-configuration.nix "${MACHINE}"
    git add "${MACHINE}"
    log::status

    popd &>/dev/null
    log::d "Leaving install::install_config"
}

# Create the target system config directory
install::install_config_dir()
{
    log::header1 "Configure new system nix config"

    log::ls -n "Create the NixOS config dir ${cyan}${CONFIG_DIR}${none}..."
    mkdir -p ${CONFIG_DIR}
    log::status

    log::ls -n "Stage NIXOS configuration files at ${cyan}${CONFIG_DIR}${none}..."
    cp -r $SCRIPT_DIR/. ${CONFIG_DIR}
    log::status

    # In the local debug case we'll already have a git repo otherwise convert
    if [[ ! -d "${CONFIG_DIR}/.git" ]]; then
        pushd "${CONFIG_DIR}" &>/dev/null
        log::ls -n "Convert ${cyan}${CONFIG_DIR}${none} into git repo..."
        git init &>/dev/null
        git add . &>/dev/null
        git commit -m "init" &>/dev/null
        log::status
        popd &>/dev/null
    fi

    log::ls -n "Generating hardware configuration..."
    nixos-generate-config --root ${ROOT_DIR} &>/dev/null
    log::status

    # Extract the current NIXOS version from the generated configuration.nix file
    GEN_CONFIG="${CONFIG_DIR}/configuration.nix"
    NIXOS_VER=$(sed -n 's|^\s*system.stateVersion\s*=\s*"\(.*\)";.*|\1|p' "${GEN_CONFIG}")
    rm -f "${GEN_CONFIG}" # clean up

    log::ls -n "Update the swap entry to use the device UUID..."
    local swap_uuid=$(blkid -s UUID -o value ${PART_SWAP})
    utils::replace "${CONFIG_DIR}/hardware-configuration.nix" str "${PART_SWAP}" "/dev/disk/by-uuid/${swap_uuid}"
    log::status
    log::d "Leaving install::install_config_dir"
}

# Prompt the user to select for misc options
install::select_misc_options()
{
    # Collect auto login choice from user
    # ----------------------------------------------------------------------------------------------
    if [[ "x$DEFAULT" != "xy" ]]; then
        utils::read AUTO_LOGIN 'Do you want to auto login' 'n'
    fi

    # Collect services selections from user
    # ----------------------------------------------------------------------------------------------
    if [[ "x$DEFAULT" != "xy" ]]; then
        utils::read NFS_SHARES 'Do you want to mount pre-defined nfs shares' 'n'
    fi
    log::d "Leaving install::select_misc_options"
}

# Prompt the user to select user options
install::select_user_options()
{
    if [[ "x$DEFAULT" != "xy" ]]; then
        log::header0 "Create new user account:"
        log::subln3 "Account includes: user & email, git user & email and full name\n"
        utils::read USER_NAME 'Enter new user name' $USER_NAME
        utils::read USER_EMAIL 'Enter new user email' $USER_EMAIL
        while true; do
            utils::read USER_PASS 'Enter new password' 'admin' 's'
            utils::read USER_PASS2 'Enter password again' 'admin' 's'
            [ "x$USER_PASS" == "x$USER_PASS2" ] && break
            echo -e "   ${red}Passwords don't match, please try again${none}"
        done
        utils::read GIT_USER 'Enter git user name' $USER_NAME
        utils::read GIT_EMAIL 'Enter git user email' $USER_EMAIL
        utils::read FULL_NAME 'Enter full name' $USER_NAME
    fi
    log::d "Leaving install::select_user_options"
}

# Prompt the user to select the date and time options
install::select_date_time_options()
{
    if [[ "x$DEFAULT" != "xy" ]]; then
        log::header0 "Configure time and date:"
        utils::read TIMEZONE 'Enter timezone' "$TIMEZONE"
        utils::read TIMEDATE_SET "Change time ${cyan}$(date --iso-8601=seconds) UTC${none}" 'n'
        if [ "x$TIMEDATE_SET" == "xy" ]; then
            while true; do
                utils::read TIMEDATE "Use ${cyan}ISO 8601 seconds${none} format" "$(date --iso-8601=seconds)"
                date -s "${TIMEDATE}" &>/dev/null
                [ $? -eq 0 ] && break
            done
        fi
    fi
    log::d "Leaving install::select_date_time_options"
}

# Prompt the user to select the networking options
install::select_networking_options()
{
    if [[ "x$DEFAULT" != "xy" ]]; then
        log::header0 "Configure networking:"
        utils::read HOSTNAME 'Enter hostname' $HOSTNAME
        utils::read IP 'Enter static IP, e.g. 192.168.1.2/24' 'DHCP'
        if [[ "x${IP}" != "xDHCP" ]]; then
            utils::read SUBNET 'Enter subnet' $(echo $IP | awk -F. '{print $1"."$2"."$3".0/24"}')
            utils::read GATEWAY 'Enter gateway' $(echo $IP | awk -F. '{print $1"."$2"."$3".1"}')
            utils::read PRIMARY_DNS 'Enter primary dns' $(echo $IP | awk -F. '{print $1"."$2"."$3".53"}')
            utils::read FALLBACK_DNS 'Enter fallback dns' $(echo $IP | awk -F. '{print $1"."$2"."$3".53"}')
        fi
        utils::read BLUETOOTH 'Enable bluetooth support' 'n'
    fi
    log::d "Leaving install::select_networking_options"
}

# Prompt the user to select the disk to install to
install::select_install_disk_options()
{
    # Read in the potential destination disks details
    # [Major Device numers](https://www.kernel.org/doc/Documentation/admin-guide/devices.txt)
    # Filtering out: loop (7), floppy (2), CD-ROM (11, 15, 20, 24, 25, 26, 27, 28, 29, 30, 32)
    local excludes=2,7,11,15,20,24,25,26,27,28,29,30,32

    # Get all disks, sort by size and filter out any that are measured in bytes or megabytes
    #
    # ### Paramaters
    # -d    do not print holder devices or slaves
    # -n    do not print headings line
    # -e    exclude sepcified devices, loop(7), floppy(2)
    # -x    sort by the size of the drive smallest first
    DISKS_DETAILED=$(lsblk -dn -e ${excludes} -o NAME,SIZE,MODEL,TYPE,HOTPLUG,LABEL -x SIZE --json | \
      jq -rc '[.blockdevices[] | . += {mag: (.size | capture("(?<other>[0-9.]+)(?<value>[A-Z])")) } | select(.type == "disk" and .hotplug != true and .mag.value != "M" and .mag.value != "B" and .label != "cyberlinux-installer")]')

    # Get all the disks by name to provide to the user for selection
    DISKS=($(echo ${DISKS_DETAILED} | jq -rc '[.[].name] | map("/dev/"+.) | .[]'))

    # Select the smallest sized disk by default i.e. most likely be the boot drive
    DESTDEV=$(echo ${DISKS_DETAILED} | jq -rc '[.[].name] | map("/dev/"+.) | .[0]')

    # Print out the detected disks
    [[ "x$DEFAULT" != "xy" ]] && log::header0 "Select a disk as your install destination:" || true
    local i=0
    echo $DISKS_DETAILED | jq -rc '.[]' | while read x; do
        i=$((i+1))
        local disk="/dev/$(echo $x | jq -r '.name')"
        local size="$(echo $x | jq -r '.size')"
        local model="$(echo $x | jq -r '.model')"
        [[ "x$DEFAULT" != "xy" ]] && echo -en "   ${i}) [${cyan}${disk}${none}](${cyan}${size}${none})" || true
        [[ "x$DEFAULT" != "xy" ]] && [ "$model" != "null" ] && echo -en " - ${model}" || true
        [[ "x$DEFAULT" != "xy" ]] && echo "" || true
    done

    # Get user choice
    if [[ "x$DEFAULT" != "xy" ]]; then
        utils::select DESTDEV "${DISKS[@]}"
    fi

    [ "x${DEBUG}" == "x1" ] && log::d "User selected: $DESTDEV"

    # Determine the storage drive partition pattern.
    # ----------------------------------------------------------------------------------------------
    # https://wiki.archlinux.org/title/Device_file#Block_devices
    # Typically this is of the form device name followed by a number or device name
    # followed by a number with a 'p' prefix. I've only seen two different styles so far.
    #
    # Older style
    # - SCSI: /dev/sda        partition1: /dev/sda1
    # - QEMU: /dev/vda        partition1: /dev/vda1
    # Modern style
    # - NVMe: /dev/nvme0n1    partition1: /dev/nvme0n1p1
    # - MMC:  /dev/mmcblk0    partition1: /dev/mmcblk0p1

    # Match DESTDEV with /dev/sda and /dev/vda
    [ -z "${DESTDEV##*/dev/sd*}" ] || [ -z "${DESTDEV##*/dev/vd*}" ] && SCSI=1

    # Determine the disk partitioning mode to use:
    # - Modern systems from 2012 support the GPT partition table supporting disks >= 2TB
    # - Legacy systems with older BIOS versions require a MBR partition table and disks <= 2TB
    if [[ $EFI -eq 0 && -f /sys/class/dmi/id/bios_date ]]; then
        bios_year=$(awk -F'/' '{print $3}' /sys/class/dmi/id/bios_date) 
        if [ $bios_year -le 2012 ]; then
            MBR=1
            log::d "Legacy BIOS detected using ${cyan}MBR partition table${none}"
        fi
    fi
    if [ $MBR -eq 0 ]; then
        log::d "Newer BIOS/UEFI detected using ${cyan}GPT partition table${none}"
    fi

    log::d "Leaving install::select_install_disk_options"
}

# Prompt the user to choose whether to install a new system or reinstall an existing machine.
# - profile selections beyond what the ISO was built with will incur network downloads
install::select_deployment_options()
{
    log::header0 "Select a deployment option:"
    utils::read NEW_MACHINE 'Are you deploying an existing machine' 'n'
    if [[ "x$NEW_MACHINE" == "xn" ]]; then
        local profiles_dir="${SCRIPT_DIR}/profiles"
        local _profiles=($(echo $(find $profiles_dir -name "*.nix" | sort)))
        log::header0 "Select a deployment profile:"
        local i=0
        for j in "${!_profiles[@]}"; do # ! means loop over indices instead of values
            local x=${_profiles[$j]}

            # Check if the profile contains the "# - Directly installable" string
            local desc=$(grep "# - Directly installable" ${x} 2>/dev/null)
            if [[ "x${desc}" != "x" ]]; then
                desc="${desc#*: }"                # grab the suffixed description of the install option
                x=${x//$profiles_dir\/}           # trim off the suffix dir
                x=${x//.nix}                      # trim off the extension
                utils::pad_suffix _1 "$x" " " 20  # pad to 30 characters
                PROFILES+=($x)                    # add to the final profiles list
                echo -e "   $((i+1))) ${cyan}${_1}${none}${desc}" # print out padded entry with description
                i=$((i+1))                  # increment i
            fi
        done
        utils::select PROFILE "${PROFILES[@]}"
        PROFILE="profiles/${PROFILE}.nix"
    else
        local machines_dir="${SCRIPT_DIR}/machines"
        local _machines=($(echo $(find $machines_dir -mindepth 1 -maxdepth 1 -type d -not -path "*/machines/vm*" | sort)))
        log::header0 "Select a deployment machine:"
        local i=0
        for x in "${_machines[@]}"; do
            local _machine="$(basename "$x")"
            utils::pad_suffix _1 "$_machine" " " 20           # pad to 30 characters
            MACHINES+=($_machine)                             # add to the final profiles list
            echo -e "   $((i+1))) ${cyan}${_1}${none}${desc}" # print out padded entry with description
            i=$((i+1))                                        # increment i
        done
        utils::select MACHINE "${MACHINES[@]}"
        MACHINE="machines/${MACHINE}"
    fi
    log::d "Leaving install::select_deployment_options"
}

# Start the install wizard
# - $CONFIG_DIR is set in ../clu to the $SCRIPT_DIR by default
# - we override $CONFIG_DIR to be /mnt/etc/nixos during install for install context
# --------------------------------------------------------------------------------------------------
install::run()
{
    core::preamble
    args=($@)

    # Optionally enable testing
    if [[ "${args[0]}" == "testing" ]]; then
        log::header0 "Testing installer with local nixos-config"
        TESTING="y"
        ROOT_DIR=.      # use local nixos-config
        CONFIG_DIR=.
    else
        ROOT_DIR="/mnt"
        CONFIG_DIR="${ROOT_DIR}/etc/nixos"
    fi

    DEFAULT="n"
    TESTING="${TESTING:-n}"
    MBR=0
    [ -d /sys/firmware/efi ] && EFI=1 || EFI=0
    SCSI=0
    TIMEZONE='America/Boise'

    # Network settings
    HOSTNAME='nixos'
    IP='DHCP'

    # User settings
    GIT_USER='admin'
    GIT_EMAIL='nixos@nixos.org'
    FULL_NAME='admin'
    USER_EMAIL='nixos@nixos.org'
    USER_NAME='admin'
    USER_PASS='admin'
    DEFAULT_PASS='admin'
    AUTO_LOGIN='n'

    # Machine profile and services settings
    MACHINE=''
    PROFILE=''
    NEW_MACHINE='y'
    NFS_SHARES='n'

    # Prompt install a brand new machine or reinstall an existing machine
    install::select_deployment_options

    # Determine if this is a default deployment
    # ----------------------------------------------------------------------------------------------
    log::header0 "Select deployment options:"
    utils::read DEFAULT 'Use automatic mode with defaults?' 'n'

    # Drop out debug variables if in debug mode
    # ----------------------------------------------------------------------------------------------
    log::d "Entering debug mode"
    log::d "Debug lines are prefixed with violet ${violet}>>${none}"
    log::vars

    install::select_install_disk_options

    install::select_networking_options

    install::select_date_time_options

    install::select_user_options

    install::select_misc_options

    # Dump out selections
    # ----------------------------------------------------------------------------------------------
    log::header1 "Starting installation"
    log::header0 "Options being used for installation"
    log::subln3 "machine=${cyan}${MACHINE}${none}"
    log::subln3 "profile=${cyan}${PROFILE}${none}"

    # Networking settings
    log::subln3 "hostname=${cyan}${HOSTNAME}${none}"
    log::subln3 "ip=${cyan}${IP}${none}"
    log::subln3 "subnet=${cyan}${SUBNET}${none}"
    log::subln3 "gateway=${cyan}${GATEWAY}${none}"
    log::subln3 "primary_dns=${cyan}${PRIMARY_DNS}${none}"
    log::subln3 "fallback_dns=${cyan}${FALLBACK_DNS}${none}"

    # User settings
    log::subln3 "user_name=${cyan}${USER_NAME}${none}"
    log::subln3 "user_email=${cyan}${USER_EMAIL}${none}"
    if [ "x$DEFAULT" == "xy" ] || [ "x$DEFAULT_PASS" == "x$USER_PASS" ]; then
        log::subln3 "user_pass=${cyan}${DEFAULT_PASS}${none}"
    else
        log::subln3 "user_pass=${cyan}********${none}"
    fi
    log::subln3 "git_user=${cyan}${GIT_USER}${none}"
    log::subln3 "git_email=${cyan}${GIT_EMAIL}${none}"
    log::subln3 "full_name=${cyan}${FULL_NAME}${none}"

    # System settings
    log::subln3 "nfs_shares=${cyan}${NFS_SHARES}${none}"
    log::subln3 "bluetooth=${cyan}${BLUETOOTH}${none}"
    log::subln3 "timezone=${cyan}${TIMEZONE}${none}"
    log::subln3 "auto_login=${cyan}${AUTO_LOGIN}${none}"
    log::subln3 "dest_dev=${cyan}${DESTDEV}${none}"
    log::subln3 "SCSI=${cyan}${SCSI}${none}"
    log::subln3 "MBR=${cyan}${MBR}${none}"
    log::subln3 "EFI=${cyan}${EFI}${none}"

    # Setup the NixOS configuration files
    # - Prep /mnt/etc/nixos and trigger install from that location
    # ----------------------------------------------------------------------------------------------
    if [[ "x$TESTING" != "xy" ]]; then

        # Partition the target disk and mount it for deployment
        install::prepare_disk

        # Create the target system config directory /mnt/etc/nixos
        install::install_config_dir

        # Create the new system's persistent configuration or stage the existing system
        if [[ "$PROFILE" == "profiles"* ]]; then
            install::install_config
        else
            log::header1 "Load existing system configuration"
            log::ls "NOT YET SUPPORTED..."
        fi

        # Perform the actual install
        install::install_system

        echo
        log::ls "${yellow}1. Power down your system:${none} sudo poweroff"
        log::ls "${yellow}2. Remove the install media${none}"
        log::ls "${yellow}3. Boot the system back up${none}"
    fi
}
