#!/usr/bin/env bash

# Installation code
# 
# ## Features
#
# --------------------------------------------------------------------------------------------------

# Usage for the install command and its sub commands
# --------------------------------------------------------------------------------------------------
install::usage()
{
    cat <<USAGE
Usage:
  install [COMMAND] [ARGS...] [OPTIONS]

Options:
  -h, --help        Print out usage

Commands:
  install [PATH]    Execute the installer with an optional alternate nixos-config destination
USAGE

    log::ln "\nExamples:"
    log::subln "Launch installer: ${green}sudo ./${SCRIPT} install${none}"
    log::subln "Launch installer with alternate nixos-config path: ${green}sudo ./${SCRIPT} install tmp${none}"
    echo
    exit
}

# Partition disk and mount for install at ${ROOT_DIR}
install::prepare_disk()
{
    log::header1 "Partitioning and mounting destination disk ${cyan}${DESTDEV}${none}..."

    # Wipe, partition and format disk
    # --------------------------------------------------------------------------
    log::ls "${red}WARNING this will DESTROY all data on disk:${none} ${cyan}${DESTDEV}${none}"
    utils::read DESTROY 'Do you wish to continue?' 'n' 'f'
    [[ "x${DESTROY}" != "xy" && "x${DESTROY}" != "xskip" ]] && exit
    [[ "x${DESTROY}" == "xskip" ]] && return

    echo -en "\n:: Destroying any magic strings and/or signatures on ${cyan}${DESTDEV}${none}..."
    wipefs --all --force ${DESTDEV} &>/dev/null
    log::status

    log::ls -n "Wiping partition table on ${cyan}${DESTDEV}${none}..."
    sgdisk --zap ${DESTDEV} &>/dev/null
    log::status

    # Set partition identifiers
    if [[ "x${SCSI}" == "x1" ]]; then
        PART_BOOT="${DESTDEV}1"
        PART_SWAP="${DESTDEV}2"
        PART_ROOT="${DESTDEV}3"
    else
        PART_BOOT="${DESTDEV}p1"
        PART_SWAP="${DESTDEV}p2"
        PART_ROOT="${DESTDEV}p3"
    fi

    # EFI: Create an ESP (EFI system partition) using linux code EF00
    # to act as a storage place for the EFI bootloaders to be launched by the UEFI firmware.
    # https://wiki.archlinux.org/index.php/EFI_System_Partition#Create_the_partition
    if [[ "x${EFI}" == "x1" ]]; then
        log::ls -n "Creating ${cyan}${PART_BOOT}${none} as ${cyan}ESP boot partition${none}..."
        sgdisk -n 0:0:+512M -t 0:EF00 -c 0:"EFI system" ${DESTDEV} &>/dev/null
        log::status

        log::ls -n "Formatting ${cyan}${PART_BOOT}${none} (ESP) as ${cyan}FAT32${none}..."
        mkfs.vfat -n "BOOT" ${PART_BOOT} &>/dev/null
        log::status

    # BIOS: Create a BIOS boot partition EF02
    else
        log::ls -n "Creating ${cyan}${PART_BOOT}${none} as ${cyan}BIOS boot partition${none}..."
        sgdisk -n 0:0:+2M -t 0:EF02 -c 0:"BIOS system" ${DESTDEV} &>/dev/null
        log::status
    fi

    # Create SWAP partition 8200
    log::ls -n "Creating ${cyan}${PART_SWAP}${none} as ${cyan}Linux swap partition${none}..."
    sgdisk -n 0:0:+4G -t 0:8200 -c 0:"Linux swap" ${DESTDEV} &>/dev/null
    log::status

    # Create root partition 8300
    log::ls -n "Creating ${cyan}${PART_ROOT}${none} as ${cyan}Linux filesystem partition${none}..."
    sgdisk -n 0:0:0 -t 0:8300 -c 0:"Linux filesystem" ${DESTDEV} &>/dev/null
    log::status

    # Set boot flag for device
    log::ls -n "Setting boot flag on ${cyan}${DESTDEV}${none}..."
    sgdisk ${DESTDEV} --attributes=3:set:2 &>/dev/null
    log::status

    # Configure swap partition
    log::ls -n "Formatting ${cyan}${PART_SWAP}${none} as ${cyan}swap${none}..."
    mkswap -L SWAP ${PART_SWAP} &>/dev/null
    log::status
    log::ls -n "Starting swap on ${cyan}${PART_SWAP}${none}..."
    swapon ${PART_SWAP} &>/dev/null
    log::status

    # mkfs.ext4 option descriptions
    # -F            force creation even if some params don't make sense
    # -L            set volume name to well known label used by bootloaders
    # -m 0          don't reserve blocks for super user daemons
    # -q            run in quiet mode for scripts
    log::ls -n "Formatting ${cyan}${PART_ROOT}${none} as ${cyan}ext4${none}..."
    mkfs.ext4 -F -m 0 -q -L ROOT ${PART_ROOT} &>/dev/null
    log::status

    # Mount root as ROOT_DIR and disable access time writes (speeds things up)
    log::ls -n "Mounting ${cyan}${PART_ROOT}${none} as ${cyan}${ROOT_DIR}${none}..."
    mount -o noatime ${PART_ROOT} ${ROOT_DIR} &>/dev/null
    log::status

    # UEFI: boot partition needs to be mounted over the root at /boot to capture the Linux
    # standard boot file install e.g. kernel and initramfs. We keep them on the same partition
    # as the EFI/BOOT/BOOTX64.efi as EFI can't mount a ext4 filesystem.
    if [[ "x${EFI}" == "x1" ]]; then
        log::ls -n "Mounting ${cyan}${PART_BOOT}${none} (ESP) as ${cyan}${ROOT_DIR}/boot${none}..."
        mkdir -p ${ROOT_DIR}/boot
        mount ${PART_BOOT} ${ROOT_DIR}/boot &>/dev/null
        log::status
    fi
    # BIOS: boot partition shouldn't be formatted or mounted in this case as its just for the MBR
    log::d "Leaving install::prepare_disk"
}

# Actual install of the system after configuration is in place
install::install_system()
{
    log::header1 "Installing NixOS based on the staged configuration"
    flake::stage_files "${MACHINE}" install

    # Run the installer: $CONFIG_DIR will be /mnt/etc/nixos unless testing
    log::ls "Launching installation with ${cyan}nixos-install${none}..."
    nixos-install --no-root-passwd --no-channel-copy --flake "${CONFIG_DIR}#target"
    if [ $? -ne 0 ]; then
        echo -e ":: ${red}Failure building the install flake${none}"
        echo -e "   1. Fix the flake issue at ${cyan}${CONFIG_DIR}${none}"
        echo -e "   2. Rerun: ${cyan}nixos-install --no-root-passwd --no-channel-copy --flake ${CONFIG_DIR}#target${none}"
    fi

    flake::unstage_files
    log::d "Leaving install::install_system"
}

# Create the new system's persistent configuration or stage the existing system
install::install_config()
{
    MACHINE="machines/$HOSTNAME"
    local machine_args="${MACHINE}/args.nix"
    log::header1 "Install system ${cyan}${MACHINE}${none}"

    # Create the new machine directory
    pushd "${CONFIG_DIR}" &>/dev/null
    mkdir "${MACHINE}"

    # Construct options array to be included in the configuration.nix
    local options=()
    options+=("id = \"$(dbus-uuidgen)\";")

    # Configure boot device target
    log::ls -n "Storing boot device type setting..."
    [[ "x${EFI}" == "x1" ]] && options+=("efi = true;") || options+=("mbr = \"${DESTDEV}\";")
    log::status

    log::ls -n "Update NIXOS target version to ${cyan}${NIXOS_VER}${none}..."
    options+=("nix.minVer = \"${NIXOS_VER}\";")
    log::status

    log::ls -n "Update set hostname and timezone..."
    options+=("hostname  = \"${HOSTNAME}\";")
    options+=("timezone = \"${TIMEZONE}\";")
    log::status

    # Extract networking for use during install
    NICS=($(ls /sys/class/net))
    log::ls -n "Storing NIC0 ${cyan}${NICS[0]}${none}..."
    options+=("net.nic0.name = \"${NICS[0]}\";")
    log::status

    # Configure new user and root user
    local pass=""
    [[ "x$DEFAULT" == "xy" ]] && pass=" (default: ${cyan}${DEFAULT_PASS}${none})" || true
    log::ls -n "Storing new ${cyan}${USER_NAME}${none} and ${cyan}root${none} passwords${pass}..."
    options+=("user.fullname = \"${FULL_NAME}\";")
    options+=("user.email = \"${USER_EMAIL}\";")
    options+=("user.name = \"${USER_NAME}\";")
    options+=("user.group = \"${USER_NAME}\";")
    options+=("user.pass = \"${USER_PASS}\";")
    options+=("git.user = \"${GIT_USER}\";")
    options+=("git.email = \"${GIT_EMAIL}\";")
    log::status

    log::ls -n "Storing new networking options..."
    [[ "x$SUBNET" != "x" ]] && options+=("net.subnet = \"${SUBNET}\";") || true
    [[ "x$GATEWAY" != "x" ]] && options+=("net.gateway = \"${GATEWAY}\";") || true
    [[ "x$PRIMARY_DNS" != "x" ]] && options+=("net.dns.primary = \"${PRIMARY_DNS}\";") || true
    [[ "x$FALLBACK_DNS" != "x" ]] && options+=("net.dns.fallback = \"${FALLBACK_DNS}\";") || true
    [[ "x$IP" != "xDHCP" ]] && options+=("net.nic0.ip = \"${IP}\";") || true
    [[ "x$SUBNET" != "x" ]] && options+=("net.nic0.subnet = \"${SUBNET}\";") || true
    [[ "x$GATEWAY" != "x" ]] && options+=("net.nic0.gateway = \"${GATEWAY}\";") || true
    [[ "x$PRIMARY_DNS" != "x" ]] && options+=("net.nic0.dns.primary = \"${PRIMARY_DNS}\";") || true
    [[ "x$FALLBACK_DNS" != "x" ]] && options+=("net.nic0.dns.fallback = \"${FALLBACK_DNS}\";") || true
    [[ "x$BLUETOOTH" == "xy" ]] && options+=("bluetooth = true;") || true
    [[ "x$AUTO_LOGIN" == "xy" ]] && options+=("autologin = true;") || true
    [[ "x$NFS_SHARES" == "xy" ]] && options+=("nfs.enable = true;") || true
    log::status

    # Write out the file to machines/$HOSTNAME/configuration.nix
    log::ls -n "Generating ${MACHINE}/configuration.nix..."
    cat > "${MACHINE}/configuration.nix" <<EOF
{ config, pkgs, lib, args, f, ... }: with lib.types;
{
  imports = [ ./hardware-configuration.nix ../../${PROFILE} ];
  config = {
    machine.type.bootable = true;
  };
}
EOF
    log::status

    # Add the /mnt/etc/nixos/machines/$HOSTNAME/args.nix
    log::ls -n "Generating install time ${machine_args}..."
    cat > "${machine_args}" <<EOF
{
$(for x in "${options[@]}"; do echo "  $x"; done)
}
EOF
    log::status

    # Files must be at least git added for the flake to recognize them
    log::ls -n "Re-locate hardware config to ${MACHINE}/hardware-configuration.nix..."
    mv hardware-configuration.nix "${MACHINE}"
    git add "${MACHINE}"
    log::status

    popd &>/dev/null
    log::d "Leaving install::install_config"
}

# Create the target system config directory
install::install_config_dir()
{
    log::header1 "Configure new system nix config"

    log::ls -n "Create the NixOS config dir ${cyan}${CONFIG_DIR}${none}..."
    mkdir -p ${CONFIG_DIR}
    log::status

    log::ls -n "Stage NIXOS configuration files at ${cyan}${CONFIG_DIR}${none}..."
    cp -r $SCRIPT_DIR/. ${CONFIG_DIR}
    log::status

    pushd "${CONFIG_DIR}" &>/dev/null
    log::ls -n "Stage NIXOS configuration files at ${cyan}${CONFIG_DIR}${none}..."
    git init 
    git add .
    git commit -m "init"
    log::status
    popd &>/dev/null

    log::ls -n "Generating hardware configuration..."
    nixos-generate-config --root ${ROOT_DIR} &>/dev/null
    log::status

    # Extract the current NIXOS version from the generated configuration.nix file
    GEN_CONFIG="${CONFIG_DIR}/configuration.nix"
    NIXOS_VER=$(sed -n 's|^\s*system.stateVersion\s*=\s*"\(.*\)";.*|\1|p' "${GEN_CONFIG}")
    rm -f "${GEN_CONFIG}" # clean up

    log::ls -n "Update the swap entry to use the device UUID..."
    local swap_uuid=$(blkid -s UUID -o value ${PART_SWAP})
    utils::replace "${CONFIG_DIR}/hardware-configuration.nix" str "${PART_SWAP}" "/dev/disk/by-uuid/${swap_uuid}"
    log::status
    log::d "Leaving install::install_config_dir"
}

# Prompt the user to select for misc options
install::select_misc_options()
{
    # Collect auto login choice from user
    # ----------------------------------------------------------------------------------------------
    if [[ "x$DEFAULT" != "xy" ]]; then
        utils::read AUTO_LOGIN 'Do you want to auto login' 'n'
    fi

    # Collect services selections from user
    # ----------------------------------------------------------------------------------------------
    if [[ "x$DEFAULT" != "xy" ]]; then
        utils::read NFS_SHARES 'Do you want to mount pre-defined nfs shares' 'n'
    fi
    log::d "Leaving install::select_misc_options"
}

# Prompt the user to select user options
install::select_user_options()
{
    if [[ "x$DEFAULT" != "xy" ]]; then
        log::header0 "Create new user account:"
        log::subln3 "Account includes: user & email, git user & email and full name\n"
        utils::read USER_NAME 'Enter new user name' $USER_NAME
        utils::read USER_EMAIL 'Enter new user email' $USER_EMAIL
        while true; do
            utils::read USER_PASS 'Enter new password' 'admin' 's'
            utils::read USER_PASS2 'Enter password again' 'admin' 's'
            [ "x$USER_PASS" == "x$USER_PASS2" ] && break
            echo -e "   ${red}Passwords don't match, please try again${none}"
        done
        utils::read GIT_USER 'Enter git user name' $USER_NAME
        utils::read GIT_EMAIL 'Enter git user email' $USER_EMAIL
        utils::read FULL_NAME 'Enter full name' $USER_NAME
    fi
    log::d "Leaving install::select_user_options"
}

# Prompt the user to select the date and time options
install::select_date_time_options()
{
    if [[ "x$DEFAULT" != "xy" ]]; then
        log::header0 "Configure time and date:"
        utils::read TIMEZONE 'Enter timezone' "$TIMEZONE"
        utils::read TIMEDATE_SET "Change time ${cyan}$(date --iso-8601=seconds) UTC${none}" 'n'
        if [ "x$TIMEDATE_SET" == "xy" ]; then
            while true; do
                utils::read TIMEDATE "Use ${cyan}ISO 8601 seconds${none} format" "$(date --iso-8601=seconds)"
                date -s "${TIMEDATE}" &>/dev/null
                [ $? -eq 0 ] && break
            done
        fi
    fi
    log::d "Leaving install::select_date_time_options"
}

# Prompt the user to select the networking options
install::select_networking_options()
{
    if [[ "x$DEFAULT" != "xy" ]]; then
        log::header0 "Configure networking:"
        utils::read HOSTNAME 'Enter hostname' $HOSTNAME
        utils::read IP 'Enter static IP, e.g. 192.168.1.2/24' 'DHCP'
        if [[ "x${IP}" != "xDHCP" ]]; then
            utils::read SUBNET 'Enter subnet' $(echo $IP | awk -F. '{print $1"."$2"."$3".0/24"}')
            utils::read GATEWAY 'Enter gateway' $(echo $IP | awk -F. '{print $1"."$2"."$3".1"}')
            utils::read PRIMARY_DNS 'Enter primary dns' $(echo $IP | awk -F. '{print $1"."$2"."$3".53"}')
            utils::read FALLBACK_DNS 'Enter fallback dns' $(echo $IP | awk -F. '{print $1"."$2"."$3".53"}')
        fi
        utils::read BLUETOOTH 'Enable bluetooth support' 'n'
    fi
    log::d "Leaving install::select_networking_options"
}

# Prompt the user to select the disk to install to
install::select_install_disk_options()
{
    # Read in the potential destination disks details
    # [Major Device numers](https://www.kernel.org/doc/Documentation/admin-guide/devices.txt)
    # Filtering out: loop (7), floppy (2), CD-ROM (11, 15, 20, 24, 25, 26, 27, 28, 29, 30, 32)
    local excludes=2,7,11,15,20,24,25,26,27,28,29,30,32

    # Get all disks, sort by size and filter out any that are measured in bytes or megabytes
    #
    # ### Paramaters
    # -d    do not print holder devices or slaves
    # -n    do not print headings line
    # -e    exclude sepcified devices, loop(7), floppy(2)
    # -x    sort by the size of the drive smallest first
    DISKS_DETAILED=$(lsblk -dn -e ${excludes} -o NAME,SIZE,MODEL,TYPE,HOTPLUG,LABEL -x SIZE --json | \
      jq -rc '[.blockdevices[] | . += {mag: (.size | capture("(?<other>[0-9.]+)(?<value>[A-Z])")) } | select(.type == "disk" and .hotplug != true and .mag.value != "M" and .mag.value != "B" and .label != "cyberlinux-installer")]')

    # Get all the disks by name to provide to the user for selection
    DISKS=($(echo ${DISKS_DETAILED} | jq -rc '[.[].name] | map("/dev/"+.) | .[]'))

    # Select the smallest sized disk by default i.e. most likely be the boot drive
    DESTDEV=$(echo ${DISKS_DETAILED} | jq -rc '[.[].name] | map("/dev/"+.) | .[0]')

    # Print out the detected disks
    [[ "x$DEFAULT" != "xy" ]] && log::header0 "Select a disk as your install destination:" || true
    local i=0
    echo $DISKS_DETAILED | jq -rc '.[]' | while read x; do
        i=$((i+1))
        local disk="/dev/$(echo $x | jq -r '.name')"
        local size="$(echo $x | jq -r '.size')"
        local model="$(echo $x | jq -r '.model')"
        [[ "x$DEFAULT" != "xy" ]] && echo -en "   ${i}) [${cyan}${disk}${none}](${cyan}${size}${none})" || true
        [[ "x$DEFAULT" != "xy" ]] && [ "$model" != "null" ] && echo -en " - ${model}" || true
        [[ "x$DEFAULT" != "xy" ]] && echo "" || true
    done

    # Get user choice
    if [[ "x$DEFAULT" != "xy" ]]; then
        utils::select DESTDEV "${DISKS[@]}"
    fi

    [ "x${DEBUG}" == "x1" ] && log::d "User selected: $DESTDEV"

    # Determine the storage drive partition pattern.
    # ----------------------------------------------------------------------------------------------
    # https://wiki.archlinux.org/title/Device_file#Block_devices
    # Typically this is of the form device name followed by a number or device name
    # followed by a number with a 'p' prefix. I've only seen two different styles so far.
    #
    # Older style
    # - SCSI: /dev/sda        partition1: /dev/sda1
    # - QEMU: /dev/vda        partition1: /dev/vda1
    # Modern style
    # - NVMe: /dev/nvme0n1    partition1: /dev/nvme0n1p1
    # - MMC:  /dev/mmcblk0    partition1: /dev/mmcblk0p1

    # Match DESTDEV with /dev/sda and /dev/vda
    [ -z "${DESTDEV##*/dev/sd*}" ] || [ -z "${DESTDEV##*/dev/vd*}" ] && SCSI=1

    log::d "Leaving install::select_install_disk_options"
}

# Prompt the user to choose whether to install a new system or reinstall an existing machine.
# - profile selections beyond what the ISO was built with will incur network downloads
install::select_deployment_options()
{
    log::header0 "Select a deployment option:"
    utils::read NEW_MACHINE 'Are you deploying an existing machine' 'n'
    if [[ "x$NEW_MACHINE" == "xn" ]]; then
        local profiles_dir="${SCRIPT_DIR}/profiles"
        local _profiles=($(echo $(find $profiles_dir -name "*.nix" | sort)))
        log::header0 "Select a deployment profile:"
        local i=0
        for j in "${!_profiles[@]}"; do # ! means loop over indices instead of values
            local x=${_profiles[$j]}

            # Check if the profile contains the "# - Directly installable" string
            local desc=$(grep "# - Directly installable" ${x} 2>/dev/null)
            if [[ "x${desc}" != "x" ]]; then
                desc="${desc#*: }"                # grab the suffixed description of the install option
                x=${x//$profiles_dir\/}           # trim off the suffix dir
                x=${x//.nix}                      # trim off the extension
                utils::pad_suffix _1 "$x" " " 20  # pad to 30 characters
                PROFILES+=($x)                    # add to the final profiles list
                echo -e "   $((i+1))) ${cyan}${_1}${none}${desc}" # print out padded entry with description
                i=$((i+1))                  # increment i
            fi
        done
        utils::select PROFILE "${PROFILES[@]}"
        PROFILE="profiles/${PROFILE}.nix"
    else
        local machines_dir="${SCRIPT_DIR}/machines"
        local _machines=($(echo $(find $machines_dir -mindepth 1 -maxdepth 1 -type d -not -path "*/machines/vm*" | sort)))
        log::header0 "Select a deployment machine:"
        local i=0
        for x in "${_machines[@]}"; do
            local _machine="$(basename "$x")"
            utils::pad_suffix _1 "$_machine" " " 20           # pad to 30 characters
            MACHINES+=($_machine)                             # add to the final profiles list
            echo -e "   $((i+1))) ${cyan}${_1}${none}${desc}" # print out padded entry with description
            i=$((i+1))                                        # increment i
        done
        utils::select MACHINE "${MACHINES[@]}"
        MACHINE="machines/${MACHINE}"
    fi
    log::d "Leaving install::select_deployment_options"
}

# Start the install wizard
# - $CONFIG_DIR is set in ../clu to the $SCRIPT_DIR by default
# - we override $CONFIG_DIR to be /mnt/etc/nixos during install for install context
# --------------------------------------------------------------------------------------------------
install::run()
{
    core::preamble
    args=($@)

    # Optionally enable testing
    if [[ "${args[0]}" == "testing" ]]; then
        log::header0 "Testing installer with local nixos-config"
        TESTING="y"
        ROOT_DIR=.      # use local nixos-config
        CONFIG_DIR=.
    else
        ROOT_DIR="/mnt"
        CONFIG_DIR="${ROOT_DIR}/etc/nixos"
    fi

    DEFAULT="n"
    TESTING="${TESTING:-n}"
    [ -d /sys/firmware/efi ] && EFI=1 || EFI=0
    SCSI=0
    TIMEZONE='America/Boise'

    # Network settings
    HOSTNAME='nixos'
    IP='DHCP'

    # User settings
    GIT_USER='admin'
    GIT_EMAIL='nixos@nixos.org'
    FULL_NAME='admin'
    USER_EMAIL='nixos@nixos.org'
    USER_NAME='admin'
    USER_PASS='admin'
    DEFAULT_PASS='admin'
    AUTO_LOGIN='n'

    # Machine profile and services settings
    MACHINE=''
    PROFILE=''
    NEW_MACHINE='y'
    NFS_SHARES='n'

    # Prompt to reinstall of an existing machine or install a brand new machine
    install::select_deployment_options

    # Determine if this is a default deployment
    # ----------------------------------------------------------------------------------------------
    log::header0 "Select deployment options:"
    utils::read DEFAULT 'Use automatic mode with defaults?' 'n'

    # Drop out debug variables if in debug mode
    # ----------------------------------------------------------------------------------------------
    log::d "Entering debug mode"
    log::d "Debug lines are prefixed with violet ${violet}>>${none}"
    log::vars

    install::select_install_disk_options

    install::select_networking_options

    install::select_date_time_options

    install::select_user_options

    install::select_misc_options

    # Dump out selections
    # ----------------------------------------------------------------------------------------------
    log::header1 "Starting installation"
    log::header0 "Options being used for installation"
    log::subln3 "machine=${cyan}${MACHINE}${none}"
    log::subln3 "profile=${cyan}${PROFILE}${none}"

    # Networking settings
    log::subln3 "hostname=${cyan}${HOSTNAME}${none}"
    log::subln3 "ip=${cyan}${IP}${none}"
    log::subln3 "subnet=${cyan}${SUBNET}${none}"
    log::subln3 "gateway=${cyan}${GATEWAY}${none}"
    log::subln3 "primary_dns=${cyan}${PRIMARY_DNS}${none}"
    log::subln3 "fallback_dns=${cyan}${FALLBACK_DNS}${none}"

    # User settings
    log::subln3 "user_name=${cyan}${USER_NAME}${none}"
    log::subln3 "user_email=${cyan}${USER_EMAIL}${none}"
    if [ "x$DEFAULT" == "xy" ] || [ "x$DEFAULT_PASS" == "x$USER_PASS" ]; then
        log::subln3 "user_pass=${cyan}${DEFAULT_PASS}${none}"
    else
        log::subln3 "user_pass=${cyan}********${none}"
    fi
    log::subln3 "git_user=${cyan}${GIT_USER}${none}"
    log::subln3 "git_email=${cyan}${GIT_EMAIL}${none}"
    log::subln3 "full_name=${cyan}${FULL_NAME}${none}"

    # System settings
    log::subln3 "nfs_shares=${cyan}${NFS_SHARES}${none}"
    log::subln3 "bluetooth=${cyan}${BLUETOOTH}${none}"
    log::subln3 "timezone=${cyan}${TIMEZONE}${none}"
    log::subln3 "auto_login=${cyan}${AUTO_LOGIN}${none}"
    log::subln3 "dest_dev=${cyan}${DESTDEV}${none}"
    log::subln3 "SCSI=${cyan}${SCSI}${none}"
    log::subln3 "EFI=${cyan}${EFI}${none}"

    # Setup the NixOS configuration files
    # - Prep /mnt/etc/nixos and trigger install from that location
    # ----------------------------------------------------------------------------------------------
    if [[ "x$TESTING" != "xy" ]]; then

        # Partition the target disk and mount it for deployment
        # Note: requires `unmount /mnt` to re-run
        install::prepare_disk

        # Create the target system config directory /mnt/etc/nixos
        install::install_config_dir

        # Create the new system's persistent configuration or stage the existing system
        if [[ "$PROFILE" == "profiles"* ]]; then
            install::install_config
        else
            log::header1 "Load existing system configuration"
            log::ls -n "NOT YET SUPPORTED..."
        fi

        # Perform the actual install
        install::install_system

        echo
        log::ls "${yellow}1. Power down your system:${none} sudo poweroff"
        log::ls "${yellow}2. Remove the install media${none}"
        log::ls "${yellow}3. Boot the system back up${none}"
    fi
}
