#!/usr/bin/env bash
#set -x

# Build code
# 
# ## Features
# * The ISO build target is 'develop' by default which is the heaviest profile and builds on all the 
# other profiles which means that all packages will be included on the ISO. By changing the ISO 
# target to something smaller like 'light' we can create a smaller ISO with less packages included.
#
# --------------------------------------------------------------------------------------------------

# Usage for the build command and its sub commands
# --------------------------------------------------------------------------------------------------
build::usage()
{
    cat <<USAGE
Usage:
  build [COMMAND] [ARGS...] [OPTIONS] 

Options:
  -h, --help                Print out usage
  --vm.service=NAME         Configure VM as systemd service when set to name
  --vm.ip=VALUE             IP Address to use for the VM
  --vm.spice=VALUE          Use SPICE for this VM (default=false) [true|false]
  --vm.spicePort=VALUE      SPICE port to use (default=5901)
  --vm.cores=VALUE          Cores to use (default=4)
  --vm.diskSize=VALUE       Disk size in GiB to use (default=20)
  --vm.memorySize=VALUE     Memory size in GiB to use (default=4)
  --vm.resolution.x=VALUE   Y Resolution value to use (default=1920)
  --vm.resolution.y=VALUE   Y Resolution value to use (default=1080)

Commands:
  iso [PROFILE]             Build the installable ISO with an optional profile override
  vm [PROFILE]              Build the VM with an optional profile override
USAGE

    log::ln "\nExamples:"
    log::subln "Build the VM: ${green}./${SCRIPT} build vm${none}"
    log::subln "Build server VM: ${green}./${SCRIPT} build vm generic/server${none}"
    log::subln "Build the installable ISO: ${green}./${SCRIPT} build iso${none}"
    log::subln "Build the installable ISO: ${green}./${SCRIPT} build iso generic/light${none}"
    echo
    exit
}

# Parse the build commands and execute
# --------------------------------------------------------------------------------------------------
build::run()
{
    utils::help "$@" "build::usage"

    local command=$1; shift
    case "$command" in
        iso) build::iso "$@" ;;
        vm) build::vm "$@" ;;
        *) log::error "Invalid build command: ${cyan}${command}${none}"; echo; build::usage ;;
    esac
}
 
# Build the installable iso
# --------------------------------------------------------------------------------------------------
# https://releases.nixos.org/
# https://discourse.nixos.org/t/nixos-reproducible-builds-minimal-installation-iso-successfully-independently-rebuilt/34756
# --------------------------------------------------------------------------------------------------
build::iso()
{
    core::title
    log::header0 "Building installable ISO"

    local profile="$1"
    if [[ "$profile" != "" ]]; then
        profile="${profile%.*}" # trim off the file extension
        _build::update_flake_args "str" "profile" "$profile"
    fi

    nix build .#nixosConfigurations.iso.config.system.build.isoImage

    [[ "$profile" != "" ]] && _build::restore_flake_args
}

# Build the vm
# --------------------------------------------------------------------------------------------------
build::vm()
{
    core::title
    log::header0 "Building VM"

    # Set arg overrides as directed
    while [ $# -gt 0 ]; do
        local arg=$1; shift
        case "$arg" in
            --vm.service*) _build::update_flake_args "bool" "vm.service" "$arg" true ;;
            --vm.ip*) _build::update_flake_args "str" "static_ip" "$arg" true ;;
            --vm.spicePort*) _build::update_flake_args "int" "vm.spicePort" "$arg" true ;;
            --vm.spice*) _build::update_flake_args "bool" "vm.spice" "$arg" true ;;
            --vm.cores*) _build::update_flake_args "int" "vm.cores" "$arg" true ;;
            --vm.diskSize*) _build::update_flake_args "int" "vm.diskSize" "$arg" true ;;
            --vm.memorySize*) _build::update_flake_args "int" "vm.memorySize" "$arg" true ;;
            --vm.resolution.x*) _build::update_flake_args "int" "vm.resolution.x" "$arg" true ;;
            --vm.resolution.y*) _build::update_flake_args "int" "vm.resolution.y" "$arg" true ;;
            --*) log::error "Invalid vm argument: ${cyan}${arg}${none}"; echo; build::usage ;;
            *) _build::update_flake_args "str" "profile" "$arg" ;;
        esac
    done

    #nix build .#nixosConfigurations.vm.config.system.build.vm

    #_build::restore_flake_args "$1"
}

# Change the given variable in the flake args file
# $1 - the kind of value [str|bool|int]
# $2 - the name of the variable to change
# $3 - the value to set
# $4 - the value is a name=value pair
_build::update_flake_args()
{
    local kind="$1"
    local var="$2"
    local value="$3"
    local pair="$4"
    local args="${SCRIPT_DIR}/flake_private.nix"

    # Parse out the value from the pair
    if [[ "$pair" == "true" ]]; then
        value="${value#*=}"     # trim the prefix including the '='
    fi

    log::ln "Updating flake args: ${cyan}${var}${none} => ${cyan}${value}${none}"
    utils::replace "${kind}" "${var}" "${value}" "${args}"
    #git add "${args}"

    # Ensure the restore is always called
    #trap _build::cleanup INT KILL
}

# Restore the flake args back to what is was before
_build::restore_flake_args()
{
    local args="${SCRIPT_DIR}/flake_private.nix"

    log::ln "Restoring flake args back to original"
    git restore --staged "${args}"
    git checkout "${args}"
}

# Cleanup if interrupted or failed after changing variables
_build::cleanup()
{
    _build::restore_flake_args
    exit 0
}
