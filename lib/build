#!/usr/bin/env bash
#set -x

# Build code
# 
# ## Features
# - The ISO build target is 'develop' by default which is the heaviest profile and builds on all the 
#   other profiles which means that all packages will be included on the ISO. By changing the ISO 
#   target to something smaller like 'light' we can create a smaller ISO with less packages included.
#
# - VM hard disk can be tiny e.g. 1 GiB as all the predefined apps and configs are in the host's nix 
#   store and mounted readonly in the VM.
# --------------------------------------------------------------------------------------------------
ARGS=""

# Usage for the build command and its sub commands
# --------------------------------------------------------------------------------------------------
build::usage()
{
    cat <<USAGE
Usage:
  build [COMMAND] [ARGS...] [OPTIONS] 

Options:
  -h, --help            Print out usage
  --service=VALUE       Configure VM as systemd service (default=false) [true|false]
  --hostname=VALUE      Configure VM hostname also used as systemd unit name (default=nixos)
  --ip=VALUE            IP Address to use for the VM
  --spice=VALUE         Use SPICE for this VM (default=false) [true|false]
  --spicePort=VALUE     SPICE port to use (default=5901)
  --cores=VALUE         Cores to use (default=4)
  --diskSize=VALUE      Disk size in GiB to use (default=20)
  --memorySize=VALUE    Memory size in GiB to use (default=4)
  --resolution.x=VALUE  Y Resolution value to use (default=1920)
  --resolution.y=VALUE  Y Resolution value to use (default=1080)
  --no-clean            Don't clean up the args file afterward

Commands:
  iso [PROFILE]         Build the installable ISO with an optional profile override
  vm [PROFILE]          Build the VM with an optional profile override
USAGE

    log::ln "\nExamples:"
    log::subln "Build the VM: ${green}./${SCRIPT} build vm${none}"
    log::subln "Build spice VM: ${green}./${SCRIPT} build vm generic/server --service=true --hostname=nixos70 --ip=192.168.1.70/24 --spice=true --spicePort=5971 --diskSize=1${none}"
    log::subln "Build the installable ISO: ${green}./${SCRIPT} build iso${none}"
    log::subln "Build the installable ISO: ${green}./${SCRIPT} build iso generic/light${none}"
    echo
    exit
}

# Parse the build commands and execute
# --------------------------------------------------------------------------------------------------
build::run()
{
    utils::help "$@" "build::usage"

    local command=$1; shift
    case "$command" in
        iso) build::iso "$@" ;;
        vm) build::vm "$@" ;;
        *) log::error "Invalid build command: ${cyan}${command}${none}"; echo; build::usage ;;
    esac
}
 
# Build the installable iso
# --------------------------------------------------------------------------------------------------
# https://releases.nixos.org/
# https://discourse.nixos.org/t/nixos-reproducible-builds-minimal-installation-iso-successfully-independently-rebuilt/34756
# --------------------------------------------------------------------------------------------------
build::iso()
{
    core::title
    log::header0 "Building installable ISO"

    local profile="$1"
    if [[ "$profile" != "" ]]; then
        profile="${profile%.*}" # trim off the file extension
        _build::update_args "str" "profile" "$profile"
    fi

    nix build .#nixosConfigurations.iso.config.system.build.isoImage

    [[ "$profile" != "" ]] && _build::restore_args
}

# Build the vm
# --------------------------------------------------------------------------------------------------
build::vm()
{
    NO_CLEAN="${NO_CLEAN:-0}"

    # TODO: pass in name?
    local machine="testvm1"
    local service="false"
    local hostname="nixos"
    ARGS="$MACHINES_DIR/$machine/args.nix"

    core::title
    log::header0 "Building VM"
    flake::switch "$machine"

    # Set arg overrides as directed
    while [ $# -gt 0 ]; do
        local arg=$1; shift
        case "$arg" in
            --hostname*)
                _build::update_args "str" "hostname" "$arg" true
                hostname="${arg#*=}" # trim the prefix including the '='
                ;;
            --service*)
                _build::update_args "bool" "service" "$arg" true
                service="${arg#*=}" # trim the prefix including the '='
                ;;
            --ip*) _build::update_args "str" "ip" "$arg" true ;;
            --spicePort*) _build::update_args "int" "spicePort" "$arg" true ;;
            --spice*) _build::update_args "bool" "spice" "$arg" true ;;
            --cores*) _build::update_args "int" "cores" "$arg" true ;;
            --diskSize*) _build::update_args "int" "diskSize" "$arg" true ;;
            --memorySize*) _build::update_args "int" "memorySize" "$arg" true ;;
            --resolution.x*) _build::update_args "int" "resolution.x" "$arg" true ;;
            --resolution.y*) _build::update_args "int" "resolution.y" "$arg" true ;;
            --no-clean) NO_CLEAN=1 ;;
            --*) log::error "Invalid vm argument: ${cyan}${arg}${none}"; echo; build::usage ;;
            *) _build::update_args "str" "profile" "$arg" ;;
        esac
    done

    # Build the vm
    nix build .#nixosConfigurations.system.config.system.build.vm

    # Move the service files 
#    if [[ "${service}" == "true" ]]; then
#        mkdir -p "/var/lib/vm-${hostname}"
#        mv "$SCRIPT_DIR/result" "/var/lib/vm-${hostname}/"
#    fi

    _build::restore_args
}

# Change the given variable in the given args file
# $1 - the kind of value [str|bool|int]
# $2 - the name of the variable to change in the args file
# $3 - the value to set
# $4 - the value is a name=value pair
_build::update_args()
{
    local kind="$1"
    local var="$2"
    local value="$3"
    local pair="$4"

    # Parse out the value from the pair
    if [[ "$pair" == "true" ]]; then
        value="${value#*=}"     # trim the prefix including the '='
    fi

    log::ln "Updating args ${ARGS}: ${cyan}${var}${none} => ${cyan}${value}${none}"
    utils::replace "${kind}" "${var}" "${value}" "$ARGS" 
    git add "${ARGS}"

    # Ensure the args are reset
    trap _build::cleanup INT KILL
}

# Restore the args back to what is was before
_build::restore_args()
{
    [ $NO_CLEAN -eq 1 ] && return

    if [[ "$(git diff --staged --name-only -- ${ARGS})" != "" ]]; then
        log::ln "Restoring args back to original"
        git restore --staged "${ARGS}"
        git checkout "${ARGS}"
    fi
}

# Cleanup if interrupted or failed after changing variables
_build::cleanup()
{
    _build::restore_args
    exit 0
}
