#!/usr/bin/env bash
#set -x

# Flake utility code
# 
# ## Features
# - Set target (machine or profile) as flake controller
# --------------------------------------------------------------------------------------------------
MACHINE=""
PROFILE=""
TARGET=""

# Ensure the config path is accurate
flake::ensure_config_path()
{
    if [[ $(utils::cwd_is_nixos_config) -eq 1 ]]; then
        log::fatal "Config directory not detected, please run clu from config directory."
    fi
}

# Ensure target was given and exists
# - $1 - machine or profile with preceding path prefix 'profiles/' or 'machines/'
#
# Example: flake::ensure_target machines/homelab
# Example: flake::ensure_target profiles/xfce/base
flake::ensure_target()
{
    local target="$1"

    # Check if the machine name is missing
    if [[ "$target" == "" || "$target" == "machines/" || "$target" == "profiles/" ]]; then
        log::ls -n "Validating target ${cyan}${target}${none} was given..."
        log::status 1
    fi

    # Check that the given target name is valid
    log::ls -n "Validating target ${cyan}${target}${none} exists..."
    if [ ! -e "${CONFIG_DIR}/$target" ]; then
        log::status 1
    else
        log::status
    fi
}

# Switch flake
# - $1 - machine or profile with preceding path prefix 'profiles/' or 'machines/'
#
# Example: flake::switch machines/homelab
flake::switch()
{
    local target="$1"
    flake::ensure_target "$target"

    local machine_flake="${CONFIG_DIR}/${target}/flake.nix"
    local machine_flake_lock="${CONFIG_DIR}/${target}/flake.lock"
    log::ls "Switching to target ${cyan}${target}${none}"

    # Stage the flake files
    if [ -e "$machine_flake" ]; then
        # Use the machine specific flake files if they exist
        log::d "Staging the machine flake files from ${cyan}${CONFIG_DIR}/${target}${none}"
        $SUDO cp "$machine_flake" "${CONFIG_DIR}/flake.nix"
        $SUDO cp "$machine_flake_lock" "${CONFIG_DIR}/flake.lock"
    else
        # Use the shared flake base files if they exist
        log::d "Staging the root flake files from ${cyan}${CONFIG_DIR}${none}"
        $SUDO cp "${CONFIG_DIR}/base.nix" "${CONFIG_DIR}/flake.nix"
        $SUDO cp "${CONFIG_DIR}/base.lock" "${CONFIG_DIR}/flake.lock"
    fi

    # Git requires being run from the correct directory
    utils::run pushd "${CONFIG_DIR}"

    # Add flake file dependencies to be seen by the configuration system
    log::d "Adding the flake files to the git repo at ${cyan}${CONFIG_DIR}${none}"
    $SUDO git add flake.nix -f
    $SUDO git add flake.lock -f

    # Decrypt if not installing
    if [ $INSTALL -eq 0 ]; then
        utils::decrypt "$CONFIG_DIR"
    fi
    exit 1

    # Optionally include machine's configuration
    if [[ "$target" == "machines"* ]]; then
        # - Using relative path here on purpose
        log::d "Link ${cyan}${CONFIG_DIR}/${target}/configuration.nix${none}"
        $SUDO ln -sf "$target/configuration.nix" configuration.nix
        log::d "Add to git repo ${cyan}${CONFIG_DIR}/${target}/configuration.nix${none}"
        $SUDO git add configuration.nix -f
        if [[ -e "${target}/args.dec.json" ]]; then
            log::d "Link ${cyan}${CONFIG_DIR}/${target}/args.dec.json${none}"
            $SUDO git add "$target/args.dec.json" -f
        fi

        # Update the target hostname
        local hostname="${target#machines/}"
        log::d "Update ${cyan}${hostname}${none} in ${cyan}${CONFIG_DIR}/args.nix${none}"
        utils::update "$SUDO" "args.nix" str "hostname" "${hostname}"
    fi

    # Update the args.nix as a mechanism to tell the flake which machine/profile to build 
    log::d "Update ${cyan}${target}${none} in ${cyan}${CONFIG_DIR}/args.nix${none}"
    utils::update "$SUDO" "args.nix" str "target" "${target}"
    log::d "Update ${cyan}git.comment${none} in ${cyan}${CONFIG_DIR}/args.nix${none}"
    utils::update "$SUDO" "args.nix" str "git.comment" "$($SUDO git log -1 --oneline --no-decorate)"
    log::d "Add to git repo ${cyan}${CONFIG_DIR}/args.nix${none}"
    $SUDO git add "args.nix"
    utils::run popd
}

# Restore the flake files back to prestine in git
flake::restore()
{
    utils::run pushd "${CONFIG_DIR}"

    if [[ "$($SUDO git diff --staged --name-only -- flake.nix flake.lock)" != "" ]]; then
        log::ls "Restoring flake files in ${cyan}${CONFIG_DIR}${none} back to prestine"
        $SUDO git restore --staged flake.nix flake.lock
    fi

    # Don't need to bother with this on install as there are no decrypted files except those we are 
    # using for staging arguments to be encrypted post install
    if [ $INSTALL -eq 0 ]; then
        if [[ "$($SUDO git diff --staged --name-only -- *.dec*)" != "" ]]; then
            log::ls "Restoring decrypted files in ${cyan}${CONFIG_DIR}${none} back to prestine"
            $SUDO git restore --staged *.dec*
        fi
    fi

    if [[ "$($SUDO git diff --staged --name-only -- configuration.nix)" != "" ]]; then
        log::ls "Restoring ${cyan}${CONFIG_DIR}/configuration.nix${none} back to prestine"
        $SUDO git restore --staged configuration.nix
    fi

    # Skip the dec files on install as were using this to stage values that have yet to get encrypted
    if [ $INSTALL -eq 0 ]; then
        if [[ "$($SUDO git diff --staged --name-only -- */*.dec*)" != "" ]]; then
            log::ls "Restoring ${cyan}${CONFIG_DIR}/*/*.dec*${none} back to prestine"
            $SUDO git restore --staged */*.dec*
        fi
    fi

    if [[ "$($SUDO git diff --staged --name-only -- args.nix)" != "" ]]; then
        log::ls "Restoring ${cyan}${CONFIG_DIR}/args.nix${none} to prestine"
        $SUDO git restore --staged args.nix
        $SUDO git checkout args.nix
    fi

    # Find and delete all decrypted files every time
    # - Don't need to to do this on install
    if [ $INSTALL -eq 0 ]; then
        $SUDO find "$CONFIG_DIR" -type f -name "*.dec*" -delete
    fi

    utils::run popd
}

# Cleanup trap function. Typically not used as the local functions will have their own which will
# call flake::restore directly
flake::trap()
{
    flake::restore
    exit 1
}

# Stage flake files for install or updates
# - files that the flake depends on must be git staged to be used.
# - $1 - machine or profile to use for switching to the given target
#
# Example: flake::switch machines/homelab
flake::stage_files()
{
    # Don't need to shutdown anything on a fresh install
    if [ $INSTALL -eq 0 ]; then
        log::ls "Shutting down ${cyan}xfconfd${none} to avoid conflicts"
        pgrep xfconfd || true
    fi

    log::ls -n "Removing ${cyan}${ROOT_DIR}/nix/files.lock${none} to permit files update..."
    $SUDO rm -f "${ROOT_DIR}/nix/files.lock"
    log::status

    flake::switch $1

    if [ $INSTALL -eq 0 ]; then
        trap flake::unstage_files EXIT
    fi
}

# Remove the tempory flake files
# - files that the flake depends but don't want persisted
flake::unstage_files()
{
    flake::restore

    log::ls -n "Adding ${cyan}${ROOT_DIR}/nix/files.lock${none} to avoid updates during reboots..."
    $SUDO touch "${ROOT_DIR}/nix/files.lock"
    log::status
}
