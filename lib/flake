#!/usr/bin/env bash
#set -x

# Flake utility code
# 
# ## Features
# - Set target (machine or profile) as flake controller
# --------------------------------------------------------------------------------------------------
MACHINE=""
PROFILE=""
TARGET=""

# Ensure the config path is accurate
flake::ensure_config_path()
{
    # Set config based on if clu is being run from the /nix/store or locally
    # - changeable config location for local runs, testing and installs
    if [[ "$SCRIPT_DIR" == "/nix/store"* ]]; then
        # Being run from the /nix/store so use the current path
        CONFIG_DIR="$(pwd)"                             
    else
        # Being run locally so it is in the root of the config dir
        CONFIG_DIR="${SCRIPT_DIR}"                             
    fi

    # Validate the chosen path has correct files
    if [[ ! -e "${CONFIG_DIR}/base.nix" || ! -e "${CONFIG_DIR}/base.lock" ]]; then
        log::fatal "Config directory not detected, please run clu from config directory."
    fi

    log::d "CONFIG_DIR: ${CONFIG_DIR}"
}

# Ensure target was given and exists
# - $1 - machine or profile with preceding path prefix 'profiles/' or 'machines/'
#
# Example: flake::ensure_target machines/homelab
# Example: flake::ensure_target profiles/xfce/base
flake::ensure_target()
{
    local target="$1"

    # Check if the machine name is missing
    if [[ "$target" == "" || "$target" == "machines/" || "$target" == "profiles/" ]]; then
        log::ls -n "Validating target ${cyan}${target}${none} was given..."
        log::status 1
    fi

    # Check that the given target name is valid
    log::ls -n "Validating target ${cyan}${target}${none} exists..."
    if [ ! -e "${CONFIG_DIR}/$target" ]; then
        log::status 1
    else
        log::status
    fi
}

# Switch flake
# - $1 - machine or profile with preceding path prefix 'profiles/' or 'machines/'
# - $2 - flag 'install' indcating behavior should be for an install
#
# Example: flake::switch machines/homelab
flake::switch()
{
    local target="$1"
    flake::ensure_target $target

    local machine_flake="${CONFIG_DIR}/${target}/flake.nix"
    local machine_flake_lock="${CONFIG_DIR}/${target}/flake.lock"
    log::ls "Switching to target ${cyan}${target}${none}"

    # Stage the flake files
    if [ -e "$machine_flake" ]; then
        # Use the machine specific flake files if they exist
        cp "$machine_flake" "${CONFIG_DIR}/flake.nix"
        cp "$machine_flake_lock" "${CONFIG_DIR}/flake.lock"
    else
        # Use the shared flake base files if they exist
        cp "${CONFIG_DIR}/base.nix" "${CONFIG_DIR}/flake.nix"
        cp "${CONFIG_DIR}/base.lock" "${CONFIG_DIR}/flake.lock"
    fi

    # Git requires being run from the correct directory
    pushd "${CONFIG_DIR}" &>/dev/null

    # Add flake file dependencies to be seen by the configuration system
    git add flake.nix -f
    git add flake.lock -f

    # Decrypt if not installing
    if [[ "$2" != "install" ]]; then
        git decrypt
        [[ -e "args.dec.json" ]] && git add "args.dec.json" -f
    fi

    # Optionally include machine's configuration
    if [[ "$TARGET" == "machines"* ]]; then
        # - Using relative path here on purpose
        ln -sf "$TARGET/configuration.nix" configuration.nix
        git add configuration.nix -f
        [[ -e "${TARGET}/args.dec.json" ]] && git add "$TARGET/args.dec.json" -f

        # Update the target hostname
        local hostname="${MACHINE#machines/}"
        utils::update "args.nix" str "hostname" "${hostname}"
    fi

    # Update the args.nix as a mechanism to tell the flake which machine/profile to build 
    utils::update "args.nix" str "target" "${TARGET}"
    utils::update "args.nix" str "git.comment" "$(git log -1 --oneline --no-decorate)"
    git add "args.nix"
    popd &>/dev/null
}

# Restore the flake files back to prestine in git
flake::restore()
{
    pushd "${CONFIG_DIR}" &>/dev/null

    if [[ "$(git diff --staged --name-only -- flake.nix flake.lock)" != "" ]]; then
        log::ls "Restoring flake files in ${cyan}${CONFIG_DIR}${none} back to prestine"
        git restore --staged flake.nix flake.lock
    fi

    if [[ "$(git diff --staged --name-only -- *.dec*)" != "" ]]; then
        log::ls "Restoring decrypted files in ${cyan}${CONFIG_DIR}${none} back to prestine"
        git restore --staged *.dec*
    fi

    if [[ "$(git diff --staged --name-only -- configuration.nix)" != "" ]]; then
        log::ls "Restoring ${cyan}${CONFIG_DIR}/configuration.nix${none} back to prestine"
        git restore --staged configuration.nix
    fi

    if [[ "$(git diff --staged --name-only -- */*.dec*)" != "" ]]; then
        log::ls "Restoring ${cyan}${CONFIG_DIR}/*/*.dec*${none} back to prestine"
        git restore --staged */*.dec*
    fi

    if [[ "$(git diff --staged --name-only -- args.nix)" != "" ]]; then
        echo -n "Restoring ${cyan}args.nix${none} to prestine"
        git restore --staged args.nix
        git checkout args.nix           # also clear changes
    fi

    # Find and delete all decrypted files every time
    find "$CONFIG_DIR" -type f -name "*.dec*" -delete

    popd &>/dev/null
}

# Cleanup trap function. Typically not used as the local functions will have their own which will
# call flake::restore directly
flake::trap()
{
    flake::restore
    exit 1
}

# Stage for tempory flake files
# - files that the flake depends on must be git staged to be used.
# - $1 - machine or profile to use for switching to the given target
# - $2 - flag 'install' indcating behavior should be for an install
#
# Example: flake::switch machines/homelab
flake::stage_files()
{
    # Don't need to shutdown anything on a fresh install
    if [[ "$2" != "install" ]]; then
        log::ls "Shutting down ${cyan}xfconfd${none} to avoid conflicts"
        pgrep xfconfd || true
    fi

    log::ls -n "Removing ${cyan}${ROOT_DIR}/nix/files.lock${none} to permit files update..."
    rm -f "${ROOT_DIR}/nix/files.lock"
    log::status

    flake::switch $1 $2

    trap flake::unstage_files EXIT
}

# Remove the tempory flake files
# - files that the flake depends but don't want persisted
flake::unstage_files()
{
    flake::restore

    log::ls -n "Adding ${cyan}${ROOT_DIR}/nix/files.lock${none} to avoid updates during reboots"
    touch "${ROOT_DIR}/nix/files.lock"
    log::status
}
